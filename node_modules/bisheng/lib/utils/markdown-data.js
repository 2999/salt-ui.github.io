'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var fs = require('fs');
var path = require('path');
var R = require('ramda');
var markTwain = require('mark-twain');

function ensureToBeArray(maybeArray) {
  return Array.isArray(maybeArray) ? maybeArray : [maybeArray];
}

function isDirectory(filename) {
  return fs.statSync(filename).isDirectory();
}

function isMDFile(filename) {
  var ext = path.extname(filename);
  return !isDirectory(filename) && ext === '.md';
}

function findMDFile(source) {
  return R.pipe(R.filter(R.either(isDirectory, isMDFile)), R.chain(function (filename) {
    if (isDirectory(filename)) {
      var subFiles = fs.readdirSync(filename).map(function (subFile) {
        return path.join(filename, subFile);
      });
      return findMDFile(subFiles);
    }
    return [filename];
  }))(source);
}

var rxSep = new RegExp('[' + path.sep + '.]');
function filesToTreeStructure(files) {
  return files.reduce(function (filesTree, filename) {
    var propLens = R.lensPath(filename.replace(/\.md$/i, '').split(rxSep));
    return R.set(propLens, filename, filesTree);
  }, {});
}

function stringifyObject(nodePath, obj, lazyLoad, depth) {
  var indent = '  '.repeat(depth);
  var kvStrings = R.pipe(R.toPairs,
  /* eslint-disable no-use-before-define */
  R.map(function (kv) {
    return indent + '  \'' + kv[0] + '\': ' + stringify(nodePath + '/' + kv[0], kv[1], lazyLoad, depth + 1) + ',';
  })
  /* eslint-enable no-use-before-define */
  )(obj);
  return kvStrings.join('\n');
}

function lazyLoadWrapper(filePath, filename) {
  return 'function () {\n' + '  return new Promise(function (resolve) {\n' + '    require.ensure([], function (require) {\n' + ('      resolve(require(\'' + filePath + '\'));\n') + ('    }, \'' + filename + '\');\n') + '  });\n' + '}';
}

function shouldLazyLoad(nodePath, nodeValue, lazyLoad) {
  if (typeof lazyLoad === 'function') {
    return lazyLoad(nodePath, nodeValue);
  }

  return (typeof nodeValue === 'undefined' ? 'undefined' : _typeof(nodeValue)) === 'object' ? false : lazyLoad;
}

function stringify(nodePath, nodeValue, lazyLoad, depth) {
  var indent = '  '.repeat(depth);
  var shouldBeLazy = shouldLazyLoad(nodePath, nodeValue, lazyLoad);
  return R.cond([[function (n) {
    return (typeof n === 'undefined' ? 'undefined' : _typeof(n)) === 'object';
  }, function (obj) {
    if (shouldBeLazy) {
      var filePath = path.join(__dirname, '..', '..', 'tmp', nodePath.replace(/^\/+/, '').replace(/\//g, '-'));
      var fileContent = 'module.exports = ' + ('{\n' + stringifyObject(nodePath, obj, false, 1) + '\n}');
      fs.writeFileSync(filePath, fileContent);
      return lazyLoadWrapper(filePath, nodePath.replace(/^\/+/, ''));
    }
    return '{\n' + stringifyObject(nodePath, obj, lazyLoad, depth) + '\n' + indent + '}';
  }], [R.T, function (filename) {
    var filePath = path.join(process.cwd(), filename);
    if (shouldBeLazy) {
      return lazyLoadWrapper(filePath, filename);
    }
    return 'require(\'' + filePath + '\')';
  }]])(nodeValue);
}

exports.generate = function generate(source) {
  if (R.is(Object, source) && !Array.isArray(source)) {
    return R.mapObjIndexed(function (value) {
      return generate(value);
    }, source);
  } else {
    var mds = findMDFile(ensureToBeArray(source));
    var filesTree = filesToTreeStructure(mds);
    return filesTree;
  }
};

exports.stringify = function (filesTree, lazyLoad) {
  return stringify('/', filesTree, lazyLoad, 0);
};

exports.traverse = function traverse(filesTree, fn) {
  Object.keys(filesTree).forEach(function (key) {
    var value = filesTree[key];
    if (typeof value === 'string') {
      fn(value);
      return;
    }

    traverse(value, fn);
  });
};

exports.process = function (filename, fileContent, plugins, isBuild /* 'undefined' | true */) {
  var markdown = markTwain(fileContent);
  markdown.meta.filename = filename;
  var parsedMarkdown = plugins.reduce(function (markdownData, plugin) {
    return require(plugin[0])(markdownData, plugin[1], isBuild === true);
  }, markdown);
  return parsedMarkdown;
};