/*! natty-fetch.pc.js v2.2.3 | MIT License | https://github.com/jias/natty-fetch */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('natty-storage')) :
  typeof define === 'function' && define.amd ? define(['natty-storage'], factory) :
  (global.nattyFetch = factory(global.nattyStorage));
}(this, (function (nattyStorage) { 'use strict';

nattyStorage = 'default' in nattyStorage ? nattyStorage['default'] : nattyStorage;

/**
 * src/util.js
 *
 * @license MIT License
 * @author jias (https://github.com/jias/natty-fetch)
 */
var hasWindow$1 = 'undefined' !== typeof window;
var doc = hasWindow$1 ? document : null;
var escape = encodeURIComponent;
var NULL$1 = null;
var TRUE$1 = true;
var FALSE$1 = !TRUE$1;
var UNDEFINED = 'undefined';
var EMPTY$1 = '';

var toString = Object.prototype.toString;
var ARRAY_TYPE = '[object Array]';
var OBJECT_TYPE = '[object Object]';

/**
 * 伪造的`promise`对象
 * NOTE 伪造的promise对象要支持链式调用 保证和`new Promise`返回的对象行为一致
 *      dummyPromise.then().catch().finally()
 */
var dummyPromise$1 = {
    dummy: TRUE$1
};

dummyPromise$1.then = dummyPromise$1['catch'] = function () {
    // NOTE 这里用了剪头函数 不能用`return this`
    return dummyPromise$1;
};

/**
 * 判断是否是IE8~11, 不包含Edge
 * @returns {boolean}
 * @note IE11下 window.ActiveXObject的值很怪异, 所以需要追加 'ActiveXObject' in window 来判断
 */
var isIE = hasWindow$1 && (!!window.ActiveXObject || 'ActiveXObject' in window);

function noop$1(v) {
    return v;
}

/**
 * 变换两个参数的函数到多个参数
 * @param  {Function} fn 基函数
 * @return {Function} 变换后的函数
 * @demo
 *      function add(x, y) { return x+y; }
 *      add = redo(add);
 *      add(1,2,3) => 6
 */
function redo(fn) {
    return function () {
        var args = arguments;
        var ret = fn(args[0], args[1]);
        for (var i = 2, l = args.length; i < l; i++) {
            ret = fn(ret, args[i]);
        }
        return ret;
    }
}

var random = Math.random;
var floor = Math.floor;
function makeRandom() {
    return floor(random() * 9e9);
}

var absoluteUrlReg = /^(https?:)?\/\//;
function isAbsoluteUrl$1(url) {
    return !!url.match(absoluteUrlReg);
}

var relativeUrlReg = /^[\.\/]/;
function isRelativeUrl$1(url) {
    return !!url.match(relativeUrlReg);
}

var BOOLEAN = 'boolean';
function isBoolean$1(v) {
    return typeof v === BOOLEAN;
}

var STRING = 'string';
function isString$1(v) {
    return typeof v === STRING;
}

var FUNCTION = 'function';
function isFunction$1(v) {
    return typeof v === FUNCTION;
}

function runAsFn$1(v) {
    return isFunction$1(v) ? v() : v;
}

var NUMBER = 'number';
function isNumber(v) {
    return !isNaN(v) && typeof v === NUMBER;
}

var OBJECT = 'object';
function isObject(v) {
    return typeof v === OBJECT && v !== NULL$1;
}

function isWindow(v) {
    return v !== NULL$1 && v === v.window;
}

// 参考了zepto
function isPlainObject$1(v) {
    return v !== NULL$1 && isObject(v) && !isWindow(v) && Object.getPrototypeOf(v) === Object.prototype;
}

function isEmptyObject$1(v) {
    var count = 0;
    for (var i in v) {
        if (v.hasOwnProperty(i)) {
            count++;
        }
    }
    return count === 0;
}

function isArray$1(v) {
    return toString.call(v) === ARRAY_TYPE;
}

/**
 * 判断是否跨域
 * @type {Element}
 * @note 需要特别关注IE8~11的行为是不一样的!!!
 */
var originA;
if(doc) {
    originA = doc.createElement('a');
    originA.href = location.href;
}
function isCrossDomain(url) {

    var requestA = doc.createElement('a');
    requestA.href = url;

    // 如果`url`的值不包含`protocol`和`host`(比如相对路径), 在标准浏览器下, 会自定补全`requestA`对象的`protocal`和`host`属性.
    // 但在IE8~11下, 不会自动补全. 即`requestA.protocol`和`requestA.host`的值都是空的.
    // 在IE11的不同小版本下, requestA.protocol的值有的是`:`, 有的是空字符串, 太奇葩啦!
    {
        if (isIE && (requestA.protocol === ':' || requestA.protocol === '')) {
            if (requestA.hostname === '') {
                //alert(0)
                return false;
            } else {
                //alert('1:'+(originA.hostname !== requestA.hostname || originA.port !== requestA.port))
                return originA.hostname !== requestA.hostname || originA.port !== requestA.port;
            }
        }
    }

    // 标准浏览器
    return originA.hostname !== requestA.hostname || originA.port !== requestA.port || originA.protocol !== requestA.protocol;
}

/**
 * 对象扩展
 * @param  {Object} receiver
 * @param  {Object} supplier
 * @return {Object} 扩展后的receiver对象
 * @note 这个extend方法是定制的, 不要拷贝到其他地方用!!!
 * @note 这个extend方法是深拷贝方式的!!!
 */
function _extend(receiver, supplier, deepCopy) {
    if ( receiver === void 0 ) receiver = {};
    if ( supplier === void 0 ) supplier = {};
    if ( deepCopy === void 0 ) deepCopy = FALSE$1;

    for (var key in supplier) {
        // `supplier`中不是未定义的键 都可以执行扩展
        if (supplier.hasOwnProperty(key) && supplier[key] !== undefined) {
            if (deepCopy === TRUE$1) {
                if (isArray$1(supplier[key])) {
                    receiver[key] = [].concat(supplier[key]);
                } else if (isPlainObject$1(supplier[key])) {
                    receiver[key] = extend$1({}, supplier[key]);
                } else {
                    receiver[key] = supplier[key];
                }
            } else {
                receiver[key] = supplier[key];
            }
        }
    }
    return receiver;
}

var extend$1 = redo(_extend);
function likeArray(v) {
    if (!v) {
        return false;
    }
    return typeof v.length === NUMBER;
}

/**
 *
 * @param v {Array|Object} 遍历目标对象
 * @param fn {Function} 遍历器 会被传入两个参数, 分别是`value`和`key`
 */
function each(v, fn) {
    var i, l;
    if (likeArray(v)) {
        for (i = 0, l = v.length; i < l; i++) {
            if (fn.call(v[i], v[i], i) === false) { return; }
        }
    } else {
        for (i in v) {
            if (fn.call(v[i], v[i], i) === false) { return; }
        }
    }
}

/**
 * 将对象的`键`排序后 返回一个新对象
 *
 * @param obj {Object} 被操作的对象
 * @returns {Object} 返回的新对象
 * @case 这个函数用于对比两次请求的参数是否一致
 */
function sortPlainObjectKey$1(obj) {
    var clone = {};
    var key;
    var keyArray = [];
    for (key in obj) {
        if (obj.hasOwnProperty(key)) {
            keyArray.push(key);
            if (isPlainObject$1(obj[key])) {
                obj[key] = sortPlainObjectKey$1(obj[key]);
            }
        }
    }
    keyArray.sort();
    for (var i=0, l=keyArray.length; i<l; i++) {
        clone[keyArray[i]] = obj[keyArray[i]];
    }
    return clone;
}

function serialize(params, obj, traditional, scope) {
    var type, array = isArray$1(obj), hash = isPlainObject$1(obj);
    each(obj, function(value, key) {
        type = toString.call(value);
        if (scope) {
            key = traditional ? scope : scope + '[' + (hash || type == OBJECT_TYPE || type == ARRAY_TYPE ? key : '') + ']';
        }

        // 递归
        if (!scope && array) {
            params.add(value.name, value.value);
        }
        // recurse into nested objects
        else if (type == ARRAY_TYPE || (!traditional && type == OBJECT_TYPE)) {
            serialize(params, value, traditional, key);
        } else {
            params.add(key, value);
        }
    });
}

/**
 * 功能和`Zepto.param`一样
 * @param obj {Object}
 * @param traditional {Boolean}
 * @returns {string}
 * $.param({ foo: { one: 1, two: 2 }}) // "foo[one]=1&foo[two]=2)"
 * $.param({ ids: [1,2,3] })           // "ids[]=1&ids[]=2&ids[]=3"
 * $.param({ ids: [1,2,3] }, true)     // "ids=1&ids=2&ids=3"
 * $.param({ foo: 'bar', nested: { will: 'not be ignored' }})    // "foo=bar&nested[will]=not+be+ignored"
 * $.param({ foo: 'bar', nested: { will: 'be ignored' }}, true)  // "foo=bar&nested=[object+Object]"
 * $.param({ id: function(){ return 1 + 2 } })  // "id=3"
 */
function param(obj, traditional) {
    var params = [];
    params.add = function (key, value) {
        if (isFunction$1(value)) { value = value(); }
        if (value == NULL$1) { value = ''; }
        params.push(escape(key) + '=' + escape(value));
    };
    serialize(params, obj, traditional);
    return params.join('&').replace(/%20/g, '+');
}

function decodeParam(str) {
    return decodeURIComponent(str.replace(/\+/g, ' '));
}

// 给URL追加查询字符串
function appendQueryString(url, obj, urlStamp, traditional) {
    // 是否添加时间戳
    if (urlStamp) {
        obj[isBoolean$1(urlStamp) ? '_stamp' : urlStamp] = +new Date();
    }
    var queryString = param(obj, traditional);

    if (queryString) {
        return url + (~url.indexOf('?') ? '&' : '?') + queryString;
    } else {
        return url;
    }
}

var util = Object.freeze({
	hasWindow: hasWindow$1,
	doc: doc,
	escape: escape,
	NULL: NULL$1,
	TRUE: TRUE$1,
	FALSE: FALSE$1,
	UNDEFINED: UNDEFINED,
	EMPTY: EMPTY$1,
	dummyPromise: dummyPromise$1,
	isIE: isIE,
	noop: noop$1,
	redo: redo,
	makeRandom: makeRandom,
	isAbsoluteUrl: isAbsoluteUrl$1,
	isRelativeUrl: isRelativeUrl$1,
	isBoolean: isBoolean$1,
	isString: isString$1,
	isFunction: isFunction$1,
	runAsFn: runAsFn$1,
	isNumber: isNumber,
	isObject: isObject,
	isWindow: isWindow,
	isPlainObject: isPlainObject$1,
	isEmptyObject: isEmptyObject$1,
	isArray: isArray$1,
	isCrossDomain: isCrossDomain,
	extend: extend$1,
	likeArray: likeArray,
	each: each,
	sortPlainObjectKey: sortPlainObjectKey$1,
	serialize: serialize,
	param: param,
	decodeParam: decodeParam,
	appendQueryString: appendQueryString
});

/**
 * src/defer.js
 *
 * @license MIT License
 * @author jias (https://github.com/jias/natty-fetch)
 */
var Defer = function Defer(Promise) {
  var t = this;
  t.promise = new Promise(function (resolve, reject) {
    t._resolve = resolve;
    t._reject = reject;
  });
};

Defer.prototype.resolve = function resolve (value) {
  this._resolve.call(this.promise, value);
};

Defer.prototype.reject = function reject (reason) {
  this._reject.call(this.promise, reason);
};

/**
 * src/event.js
 *
 * @license MIT License
 * @author jias (https://github.com/jias/natty-fetch)
 */
var PREFIX = '_';
function rename (type) { return PREFIX + type; }

var event = {
    on : function () {
        var t    = this;
        var args = arguments;
        if (typeof args[0] === 'string' && typeof args[1] === 'function') {
            var type = rename(args[0]);
            t[type]  = t[type] || [];
            t[type].push(args[1]);
        } else if (typeof args[0] === 'object') {
            var hash = args[0];
            for (var i in hash) {
                t.on(i, hash[i]);
            }
        }
    },
    off : function (type, fn) {
        var t = this;
        var type = rename(type);
        if (!fn) {
            delete t[type];
        } else {
            var fns = t[type];
            fns.splice(fns.indexOf(fn), 1);
            if (!t[type].length) { delete t[type]; }
        }
    },
    // @param {array} args
    fire : function (type, args, context) {
        var t = this;
        var fns = t[rename(type)];
        if (!fns) { return 'NO_EVENT'; }
        for (var i=0, fn; fn = fns[i]; i++) {
            fn.apply(context || t, [].concat(args));
        }
    },
    hasEvent : function (type) {
        return !!this[rename(type)];
    }
};

/**
 * src/ajax.pc.js
 *
 * @license MIT License
 * @author jias (https://github.com/jias/natty-fetch)
 */
var GET = 'GET';
var SCRIPT = 'script';
var XML = 'xml';
var JS0N = 'json'; // NOTE 不能使用`JSON`，这里用数字零`0`代替了字母`O`

var xhrTester = UNDEFINED !== typeof XMLHttpRequest ? new XMLHttpRequest() : {};
var hasXDR = UNDEFINED !== typeof XDomainRequest;
var fallback = hasWindow$1 ? (!('withCredentials' in xhrTester) && hasXDR) : null;
var supportCORS = hasWindow$1 ? (('withCredentials' in xhrTester) || hasXDR) : null;

// minetype的简写映射
// TODO 考虑是否优化
var acceptToRequestHeader = {
    // IIS returns `application/x-javascript` 但应该不需要支持
    '*':    '*/' + '*',
    script: 'text/javascript, application/javascript, application/ecmascript, application/x-ecmascript',
    json:   'application/json, text/json',
    xml:    'application/xml, text/xml',
    html:   'text/html',
    text:   'text/plain'
};

// 设置请求头
// 没有处理的事情：跨域时使用者传入的多余的Header没有屏蔽 没必要
var setHeaders = function (xhr, options) {
    if (!xhr.setRequestHeader) {
        return;
    }

    var header = {
        Accept: acceptToRequestHeader[options.accept]
    };

    // 如果没有跨域 则打该标识 业界通用做法
    // TODO 如果是跨域的 只有有限的requestHeader是可以使用的 待补充注释
    if (!isCrossDomain(options.url)) {
        header['X-Requested-With'] = 'XMLHttpRequest';
    }

    extend$1(header, options.header);

    // 如果是`POST`请求，根据options.postDataFormat设置对应的Content-Type
    // FORM和JSON都强制使用对应的Content-Type，RAW则不改动Content-Type的值，由调用者指定
    if (options.method === 'POST') {
        var pdf = options.postDataFormat;
        var contentType = (pdf === 'FORM')
            ? 'application/x-www-form-urlencoded; charset=UTF-8'
            : (pdf === 'JSON')
                ? 'application/json; charset=UTF-8'
                : NULL$1;
        if (contentType !== NULL$1)
            { header['Content-Type'] = contentType; }
    }

    for (var key in header) {
        xhr.setRequestHeader(key, header[key]);
    }
};

// 绑定事件
var setEvents = function (xhr, options, isCrossDomain$$1) {

    var completeFn = function() {
        if (xhr._completed) {
            return;
        }
        xhr._completed = true;
        //options.log && console.info('~loadend');
        options.complete();
        xhr._aborted = null;
        delete xhr._aborted;
    };

    var onLoadFn = function() {

        if (xhr._completed) {
            return;
        }

        var data = xhr.responseText;

        switch (options.accept) {
            case JS0N:
                try {
                    data = JSON.parse(data);
                } catch (e) {
                    console.warn('The response can NOT be parsed to JSON object.', data);
                }
                break;
            case SCRIPT:
                (1, eval)(data);
                break;
            case XML:
                data = xhr.responseXML;
                break;
            default:
                break;
        }

        options.success(data, xhr);
        //C.log('complete after load');
        completeFn();
    };

    var onErrorFn = function () {
        if (xhr._completed) {
            return;
        }
        options.error(xhr.status, xhr);
        //C.log('complete after error');
        completeFn();
    };

    var abortFn = function() {
        if (xhr._completed) {
            return;
        }
        options.abort();
        completeFn();
    };

    // 如果是IE8/9 且 如果是跨域请求
    if (fallback && isCrossDomain$$1) {

        // `XDomainRequest`实例是没有`onreadystatechange`方法的!!!
        xhr.onload = onLoadFn;
    } else {
        // readyState value:
        //   0: UNSET 未初始化
        //   1: OPENED
        //   2: HEADERS_RECEIVED
        //   3: LOADING
        //   4: DONE 此时触发load事件
        xhr.onreadystatechange = function () {

            if (xhr._completed) {
                return
            }
            //console.log('xhr.readyState', xhr.readyState, 'xhr.status', xhr.status, xhr);
            if (xhr.readyState == 4) {

                // 如果请求被取消(aborted) 则`xhr.status`会是0 所以不会进入`success`回调
                if ((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304) {
                    onLoadFn();
                } else {
                    // 因为取消时会先触发原生的`onreadystatechange`响应，后触发`onAbort`回调，所以
                    // 如果请求被取消(aborted) 则`xhr.status`会是0 程序走到这里的时候，`xhr._aborted`状态是false，
                    // 需要排除，不应该触发`error`回调
                    !xhr._aborted && onErrorFn();
                }
            }
        };
    }

    xhr.onerror = onErrorFn;

    // 重写`abort`方法
    var originAbort = xhr.abort;
    xhr.abort = function() {
        if (xhr._completed) {
            return
        }
        xhr._aborted = true;
        // NOTE 直接调用`originAbort()`时 浏览器会报 `Illegal invocation` 错误

        // 非IE浏览器才会真正的调用原生`abort`
        // https://github.com/jias/natty-fetch/issues/27
        if (!isIE) {
            originAbort.call(xhr);
        }

        // `XDomainRequest`对象实例居然没有`onabort`方法
        abortFn();
    };

    // IE9 bug
    xhr.onprogress = xhr.ontimeout = noop$1;
};

var defaultOptions = {
    url: '',
    mark: {},
    useMark: true,
    method: GET,
    accept: '*',
    data: null,
    header: {},
    withCredentials: NULL$1, // 根据`url`是否跨域决定默认值. 如果显式配置该值(必须是布尔值), 则个使用配置值
    urlStamp: true,
    success: noop$1,
    error: noop$1,
    complete: noop$1,
    abort: noop$1,
    log: FALSE$1,
    traditional: FALSE$1,
    postDataFormat: 'FORM'
};

function ajax(options) {

    options = extend$1({}, defaultOptions, options);

    // 是否跨域
    var isCD = isCrossDomain(options.url);

    // H5版本
    // `IE10+`和标准浏览器的`XMLHttpRequest`都原生支持跨域
    var xhr = new XMLHttpRequest();

    // `IE8/9`使用`XDomainRequest`来实现跨域, `IE10+`的`XMLHttpRequest`对象直接支持跨域
    if (fallback && isCD) {
        // NOTE `XDomainRequest`仅支持`GET`和`POST`两个方法
        // 支持的事件有: onerror, onload, onprogress, ontimeout, 注意没有`onloadend`
        // https://developer.mozilla.org/zh-CN/docs/Web/API/XDomainRequest
        xhr = new XDomainRequest();
    }

    // 再高级的浏览器都有低级错误! 已经不能在相信了!
    // MAC OSX Yosemite Safari上的低级错误: 一次`ajax`请求的`loadend`事件完成之后,
    // 如果执行`xhr.abort()`, 居然还能触发一遍`abort`和`loadend`事件!!!
    // `_completed`标识一次完整的请求是否结束, 如果已结束, 则不再触发任何事件
    xhr._completed = FALSE$1;

    setEvents(xhr, options, isCD);

    xhr.open(options.method, appendQueryString(
        options.url,
        extend$1({}, options.useMark ? options.mark : {}, options.method === GET ? options.data : {}),
        options.urlStamp,
        options.traditional
    ));

    // NOTE 生产环境的Server端, `Access-Control-Allow-Origin`的值一定不要配置成`*`!!! 而且`Access-Control-Allow-Credentials`应该是true!!!
    // NOTE 如果Server端的`responseHeader`配置了`Access-Control-Allow-Origin`的值是通配符`*` 则前端`withCredentials`是不能使用true值的
    // NOTE 如果Client端`withCredentials`使用了true值 则后端`responseHeader`中必须配置`Access-Control-Allow-Credentials`是true
    if (!fallback) {
        xhr.withCredentials = isBoolean$1(options.withCredentials) ? options.withCredentials : isCD;
    }
    
    // 设置requestHeader
    setHeaders(xhr, options);

    // 根据postDataFormat来格式化要发送的数据
    var pdf = options.postDataFormat;
    var sendData;
    if (options.method === GET || options.data === NULL$1)
        { sendData = NULL$1; }
    else
        { sendData = (pdf === 'FORM')
            ? param(options.data, options.traditional)
            : (pdf === 'JSON')
                ? JSON.stringify(options.data)
                : options.data; }
    
    // 文档建议说 send方法如果不发送请求体数据 则null参数在某些浏览器上是必须的
    xhr.send(sendData);

    return xhr;
}

ajax.fallback = fallback;
ajax.supportCORS = supportCORS;

/**
 * src/jsonp.pc.js
 *
 * @license MIT License
 * @author jias (https://github.com/jias/natty-fetch)
 */
var win = hasWindow$1 ? window : NULL$1;
var doc$1 = hasWindow$1 ? document : NULL$1;
var SCRIPT$1 = 'script';
var IE8 = hasWindow$1 ? navigator.userAgent.indexOf('MSIE 8.0') > -1 : FALSE$1;

// TODO add test spec
var removeScript = function (script) {
    if (IE8 && script.readyState) {
        script.onreadystatechange = NULL$1;
    } else {
        script.onerror = NULL$1;
    }
    script.parentNode.removeChild(script);
    script = NULL$1;
};
var head = NULL$1;
var insertScript = function (url, options) {
    var script = doc$1.createElement(SCRIPT$1);
    script.type = 'text/javascript';
    script.src = url;
    script.async = true;

    // 绑定`error`事件
    if (IE8 && script.readyState) {
        script.onreadystatechange = function () {
            // IE8下script标签不支持`onerror`事件, 通过JSONP的执行顺序来模拟触发:
            // 1:   script.readyState状态值为`loading`
            // 2.1: 如果脚本加载成功, 浏览器就会先执行脚本内容, 即调用JSONP函数, 如: `jsonp2327905726()`,
            //      (该函数执行之后会立即被设置成`null`值, 用于第3步的判断), JSONP函数执行完成后, 会进入第3步.
            // 2.2: 如果脚本加载不成功, 也会进入第3步.
            // 3:   无论脚本是否加载成功, `script.readyState`状态值都变化为`loaded`,
            //      如果加载不成功, 可以通过判断JSONP函数一定是存在, 即可模拟`error`回调了.
            if (script.readyState === 'loaded' && win[options.callbackName]) {
                win[options.callbackName] = NULL$1;
                options.error();
                options.complete();
            }
        };
    } else {
        script.onerror = function (e) {
            win[options.callbackName] = NULL$1;
            options.error(e);
            options.complete();
        };
    }

    head = head || doc$1.getElementsByTagName('head')[0];
    head.insertBefore(script, head.firstChild);
    return script;
};

var defaultOptions$1 = {
    url: '',
    mark: {},
    useMark: true,
    data: {},
    urlStamp: true,
    success: noop$1,
    error: noop$1,
    complete: noop$1,
    log: false,
    flag: 'callback',
    callbackName: 'jsonp{id}',
    traditional: FALSE$1
};

function jsonp(options) {

    options = extend$1({}, defaultOptions$1, options);

    var callbackName = options.callbackName = options.callbackName.replace(/\{id\}/, makeRandom());

    var originComplete = options.complete;

    var script;

    // 二次包装的`complete`回调
    options.complete = function () {
        // 删除脚本
        removeScript(script);
        originComplete();
    };

    // 成功回调
    win[callbackName] = function (data) {
        // JSONP函数需要立即删除 用于`IE8`判断是否触发`onerror`
        win[callbackName] = NULL$1;
        options.success(data);
        options.complete();
    };

    // 生成`url`
    var obj;
    var url = appendQueryString(
        options.url,
        extend$1(( obj = {}, obj[options.flag] = callbackName, obj ), options.useMark ? options.mark : {}, options.data),
        options.urlStamp,
        options.traditional
    );

    // 插入脚本
    script = insertScript(url, options);
    
    return {
        abort: function abort() {
            // 覆盖成功回调为无数据处理版本
            win[callbackName] = function () {
                win[callbackName] = NULL$1;
            };
            removeScript(script);
        }
    };
}

/**
 * src/plugin.loop.js
 * 创建轮询支持
 *
 * @license MIT License
 * @author jias (https://github.com/jias/natty-fetch)
 */
/**
 * 创建轮询支持
 * @param api {Function} 需要轮询的函数
 */
var pluginLoop = function(apiInstance) {
    var api = apiInstance.api;
    api.loop = function (options, resolveFn, rejectFn) {
        if ( resolveFn === void 0 ) resolveFn = noop$1;
        if ( rejectFn === void 0 ) rejectFn = noop$1;

        if (!options.duration || !isNumber(options.duration)) {
            throw new Error('Illegal `duration` value for `startLoop` method.')
        }

        var loopTimer = NULL$1;

        var stop = function () {
            clearTimeout(loopTimer);
            loopTimer = NULL$1;
            stop.looping = FALSE$1;
        };

        var sleepAndRequest = function () {
            stop.looping = TRUE$1;
            loopTimer = setTimeout(function () {
                api(options.data).then(resolveFn, rejectFn);
                sleepAndRequest();
            }, options.duration);
        };

        // NOTE 轮询过程中是不响应服务器端错误的 所以第二个参数是`noop`
        api(options.data).then(resolveFn, rejectFn);
        sleepAndRequest();
        
        return stop
    };
};

/**
 * src/plugin.soon.js
 *
 * @license MIT License
 * @author jias (https://github.com/jias/natty-fetch)
 */
var pluginSoon = function(apiInstance) {
    var t = this;
    var api = apiInstance.api;
    var config = api.config;
    api.soon = function(data, successFn, errorFn) {
        if ( successFn === void 0 ) successFn = noop$1;
        if ( errorFn === void 0 ) errorFn = noop$1;


        // 是否忽略自身的并发请求
        // NOTE 这个地方和内置的api方法不一致
        if (config.ignoreSelfConcurrent && config.pending) {
            return;
        }

        if (config.overrideSelfConcurrent && config._lastRequester) {
            config._lastRequester.abort();
            delete config._lastRequester;
        }

        // 一次请求的私有相关数据
        var vars = t.makeVars(data);

        var remoteRequest = function () {
            t.remoteRequest(vars, config).then(function (content) {
                successFn({
                    fromStorage: FALSE$1,
                    content: content
                });
            })['catch'](function (e) {
                errorFn(e);
            });
        };

        if (api.storageUseable) {

            // 只有GET和JSONP才会有storage生效
            vars.queryString = isEmptyObject$1(vars.data) ? 'no-query-string' : JSON.stringify(sortPlainObjectKey$1(vars.data));

            api.storage.has(vars.queryString).then(function (result) {

                // console.warn('has cached: ', hasValue);
                if (result.has) {
                    successFn({
                        fromStorage: TRUE$1,
                        content: result.value
                    });
                }

                // 在`storage`可用的情况下, 远程请求返回的数据会同步到`storage`
                remoteRequest();
            });
        } else {
            remoteRequest();
        }
    };
};

/**
 * src/natty-fetch.js
 *
 * @license MIT License
 * @author jias (https://github.com/jias/natty-fetch)
 */

if (nattyStorage === undefined) {
    console.warn('Please install the `natty-storage` script which is required by `natty-fetch`, go on with' +
        ' https://www.npmjs.com/package/natty-storage');
}

var extend$$1 = extend$1;
var runAsFn$$1 = runAsFn$1;
var isAbsoluteUrl$$1 = isAbsoluteUrl$1;
var isRelativeUrl$$1 = isRelativeUrl$1;
var noop$$1 = noop$1;
var isBoolean$$1 = isBoolean$1;
var isArray$$1 = isArray$1;
var isFunction$$1 = isFunction$1;
var sortPlainObjectKey$$1 = sortPlainObjectKey$1;
var isEmptyObject$$1 = isEmptyObject$1;
var isPlainObject$$1 = isPlainObject$1;
var dummyPromise$$1 = dummyPromise$1;
var isString$$1 = isString$1;
var NULL$$1 = NULL$1;
var TRUE$$1 = TRUE$1;
var FALSE$$1 = FALSE$1;
var EMPTY$$1 = EMPTY$1;
var hasWindow$$1 = hasWindow$1;

// 内置插件
// 全局默认配置
var defaultGlobalConfig = {

    // 默认参数
    data: {},

    // 请求完成钩子函数
    didFetch: noop$$1,

    // 预处理回调
    fit: noop$$1,

    // 自定义header, 只针对非跨域的ajax有效, 跨域时将忽略自定义header
    header: {},

    // 是否忽律接口自身的并发请求
    ignoreSelfConcurrent: FALSE$$1,

    // 有两种格式配置`jsonp`的值
    // {Boolean}
    // {Array} eg: [TRUE, 'cb', 'j{id}']
    jsonp: FALSE$$1,

    // 是否开启log信息
    log: FALSE$$1,

    // 非GET方式对JSONP无效
    method: 'GET',

    // 是否开启mock模式
    mock: FALSE$$1,

    mockUrl: EMPTY$$1,

    // 全局`mockUrl`前缀
    mockUrlPrefix: EMPTY$$1,

    // 全局`mockUrl`后缀
    mockUrlSuffix: EMPTY$$1,

    // 成功回调
    process: noop$$1,

    // 私有Promise对象, 如果不想用浏览器原生的Promise对象的话
    Promise: hasWindow$$1 ? window.Promise : NULL$$1,

    // 默认不执行重试
    retry: 0,

    // 使用已有的request方法
    customRequest: NULL$$1,

    // 0表示不启动超时处理
    timeout: 0,

    // http://zeptojs.com/#$.param
    traditional: FALSE$$1,

    url: EMPTY$$1,

    // 全局`url`前缀
    urlPrefix: EMPTY$$1,

    // 是否在`url`上添加时间戳, 用于避免浏览器的304缓存
    urlStamp: TRUE$$1,

    // 全局`url`后缀
    urlSuffix: EMPTY$$1,

    // TODO 文档中没有暴露
    withCredentials: NULL$$1,

    // 请求之前调用的钩子函数
    willFetch: noop$$1,

    // 扩展: storage
    storage: false,

    // 插件
    // 目前只支持两种插件
    // plugins: [
    //     nattyFetch.plugin.loop
    //     nattyFetch.plugin.soon
    // ]
    plugins: false,

    // POST的data格式，有以下三种，值严格区分大小写：
    // 1. FORM
    // 2. JSON
    // 3. RAW
    // 4. (其他任何值都将被视为RAW)
    // 默认为FORM，跟Natty-Fetch原始逻辑兼容
    postDataFormat: 'FORM'
};

var runtimeGlobalConfig = extend$$1({}, defaultGlobalConfig);

var API = function API(path, options, contextConfig, contextId) {
    var t = this;
    t.contextConfig = contextConfig;
    t._path = path;

    var config = t.config = t.processAPIOptions(options);

    /**
     * `api`的实现
     * @param data {Object|Function}
     * @returns {Object} Promise Object
     */
    t.api = function (data) {
        data = data || {};
        // 是否忽略自身的并发请求
        if (config.ignoreSelfConcurrent && t.api.pending) {
            return dummyPromise$$1;
        }

        if (config.overrideSelfConcurrent && t.api._requester) {
            t.api.abort();
        }

        var vars = t.makeVars(data);

        if (config.retry === 0) {
            return t.request(vars, config);
        } else {
            return t.tryRequest(vars, config);
        }
    };

    t.api.contextId = contextId;
    t.api._path = path;

    // 标记是否正在等待请求返回
    t.api.pending = FALSE$$1;
    t.api._requester = NULL$$1;

    // 取消响应
    t.api.abort = function () {
        if (t.api.pending && t.api._requester) {
            t.api._requester.abort();
        }
    };

    t.api.config = config;

    t.initStorage();

    // 启动插件
    var plugins = isArray$$1(config.plugins) ? config.plugins : [];
    for (var i = 0, l = plugins.length; i<l; i++) {
        isFunction$$1(plugins[i]) && plugins[i].call(t, t);
    }
};

API.prototype.makeVars = function makeVars (data) {
    var t = this;
    var config = t.config;

    // 一次请求的私有相关数据
    var vars = {
        mark: {
            _api: t._path
        }
    };

    if (config.mock) {
        vars.mark._mock = TRUE$$1;
    }

    // if (config.urlStamp) {
    // vars.mark._stamp = +new Date();
    // }

    // `data`必须在请求发生时实时创建
    // 如果postDataFormat是非FORM/JSON值时，不对data进行处理，因为这种情况下调用者意图直接向服务端传递RAW数据，
    // 这时传入的data极有可能是字符串
    // 当config.data是{}的情况下，如果调用者传入的data是字符串，经过extend()处理以后就会变成字符串数组
    // 字符串数组被后续传递给xhr.send()时会被默认调用toString()，结果就变成'[object object]'这种不合法数据
    if (config.postDataFormat === 'FORM' || config.postDataFormat === 'JSON')
        { data = extend$$1({}, runAsFn$$1(config.data), runAsFn$$1(data)); }

    // 将数据参数存在私有标记中, 方便API的`process`方法内部使用
    vars.data = data;

    return vars;
};

/**
 * 处理API的配置
 * @param options {Object}
 */
API.prototype.processAPIOptions = function processAPIOptions (options) {

    var t = this;

    // 插件是不能覆盖的, 应该追加
    var plugins = [].concat(t.contextConfig.plugins || [], options.plugins || []);

    var config = extend$$1({}, t.contextConfig, options, {
        plugins: plugins
    });

    if (config.mock) {
        config.mockUrl = t.getFullUrl(config);
    }

    config.url = t.getFullUrl(config);

    // 按照[boolean, callbackKeyWord, callbackFunctionName]格式处理
    if (isArray$$1(options.jsonp)) {
        config.jsonp = isBoolean$$1(options.jsonp[0]) ? options.jsonp[0] : FALSE$$1;
        // 这个参数只用于jsonp
        if (config.jsonp) {
            config.jsonpFlag = options.jsonp[1];
            config.jsonpCallbackName = options.jsonp[2];
        }
    }

    // 配置自动增强 如果`url`的值有`.jsonp`结尾 则认为是`jsonp`请求
    // NOTE jsonp是描述正式接口的 不影响mock接口!!!
    if (!config.mock && !!config.url.match(/\.jsonp(\?.*)?$/)) {
        config.jsonp = TRUE$$1;
    }

    return config;
};

API.prototype.initStorage = function initStorage () {
    var t = this;
    var config = t.config;

    // 开启`storage`的前提条件
    var storagePrecondition = config.method === 'GET' || config.jsonp;

    // 不满足`storage`使用条件的情况下, 开启`storage`将抛出错误
    if (!storagePrecondition && config.storage === TRUE$$1) {
        throw new Error('A `' + config.method + '` request CAN NOT use `storage` which is only for `GET/jsonp`' +
            ' request! Please check the options for `' + t._path + '`');
    }

    // 简易开启缓存的写法
    if (config.storage === TRUE$$1) {
        config.storage = {
            type: 'variable'
        };
    }

    // 决定什么情况下缓存可以开启
    t.api.storageUseable = isPlainObject$$1(config.storage)
        && (config.method === 'GET' || config.jsonp)
        && nattyStorage.support[config.storage.type];
    // 创建缓存实例
    if (t.api.storageUseable) {
        // 当使用`localStorage`时, 强制指定`key`值。如果没指定, 抛错!
        // 当使用`variable`或`sessionStorage`时, 如果没指定`key`, 则自动生成内部`key`
        // !!!为什么在使用`localStorage`时必须指定`key`值???
        // !!!因为当key发生变化时, `localStorage`很容易产生死数据, 必须强制开发者有意识的去维护`key`值
        if (config.storage.type === 'localStorage') {
            if (!config.storage.hasOwnProperty('key') || !config.storage.key) {
                throw new Error('`key` is required when `storage.type` is `localStorage`.');
            }
        } else {
            config.storage.key = config.storage.key || [t.api.contextId, t._path].join('_');
        }

        // `key`和`tag`的选择原则:
        // `key`只选用相对稳定的值, 减少因为`key`的改变而增加的残留缓存
        // 经常变化的值用于`tag`, 如一个接口在开发过程中可能使用方式不一样, 会在`jsonp`和`get`之间切换。
        t.api.storage = nattyStorage(extend$$1({}, config.storage, {
            async: TRUE$$1,
            tag: [
                config.storage.tag,
                config.jsonp ? 'jsonp' : config.method,
                config.url
            ].join('_') // 使用者的`tag`和内部的`tag`, 要同时生效
        }));
    }
};

/**
 * 请求数据(从storage或者从网络)
 * @param vars {Object} 发送的数据
 * @param config {Object} 已经处理完善的请求配置
 * @returns {Object} defer对象
 */
API.prototype.request = function request (vars, config) {
    var t = this;

    if (t.api.storageUseable) {

        // 只有GET和JSONP才会有storage生效
        vars.queryString = isEmptyObject$$1(vars.data) ? 'no-query-string' : JSON.stringify(sortPlainObjectKey$$1(vars.data));

        return t.api.storage.has(vars.queryString).then(function (data) {
            // alert(JSON.stringify(data, null, 4) + JSON.stringify(sessionStorage, null, 4));
            // console.warn('has cached: ', hasValue);
            if (data.has) {
                return data.value;
            } else {
                return t.remoteRequest(vars, config);
            }
        });
    } else {
        return t.remoteRequest(vars, config);
    }
};

/**
 * 获取正式接口的完整`url`
 * @param config {Object}
 */
API.prototype.getFullUrl = function getFullUrl (config) {
    var url = config.mock ? config.mockUrl : config.url;
    if (!url) { return EMPTY$$1; }
    var prefixKey = config.mock ? 'mockUrlPrefix' : 'urlPrefix';
    var suffixKey = config.mock ? 'mockUrlSuffix' : 'urlSuffix';
    var prefix = config[prefixKey] && !isAbsoluteUrl$$1(url) && !isRelativeUrl$$1(url) ? config[prefixKey] : EMPTY$$1;
    var suffix = config[suffixKey] ? config[suffixKey]: EMPTY$$1;
    return prefix + url + suffix;
};

/**
 * 发起网络请求
 * @param vars
 * @param config
 * @returns {Promise}
 */
API.prototype.remoteRequest = function remoteRequest (vars, config) {
    var t = this;

    // 调用 willFetch 钩子
    config.willFetch(vars, config, 'remote');

    // 等待状态在此处开启 在相应的`requester`的`complete`回调中关闭
    t.api.pending = TRUE$$1;

    var defer = new Defer(config.Promise);

    // 创建请求实例requester
    if (config.customRequest) {
        // 使用已有的request方法
        t.api._requester = config.customRequest(vars, config, defer);
    } else if (config.jsonp) {
        t.api._requester = t.sendJSONP(vars, config, defer);
    } else {
        t.api._requester = t.sendAjax(vars, config, defer);
    }

    // 超时处理
    if (0 !== config.timeout) {
        setTimeout(function () {
            if (t.api.pending && t.api._requester) {
                // 取消请求
                t.api.abort();

                var error = {
                    timeout: TRUE$$1,
                    message: 'Timeout By ' + config.timeout + 'ms.'
                };

                defer.reject(error);
                event.fire('g.reject', [error, config]);
                event.fire(t.api.contextId + '.reject', [error, config]);
            }
        }, config.timeout);
    }

    return defer.promise;
};

/**
 * 重试功能的实现
 * @param vars {Object} 发送的数据
 * @param config
 * @returns {Object} defer对象
 */
API.prototype.tryRequest = function tryRequest (vars, config) {
    var t = this;

    return new config.Promise(function (resolve, reject) {
        var retryTime = 0;
        var request = function () {
            // 更新的重试次数
            vars.mark._retryTime = retryTime;
            t.request(vars, config).then(function (content) {
                resolve(content);
                event.fire('g.resolve', [content, config], config);
                event.fire(t.api.contextId + '.resolve', [content, config], config);
            }, function (error) {
                if (retryTime === config.retry) {
                    reject(error);
                } else {
                    retryTime++;
                    request();
                }
            });
        };

        request();
    });
};

/**
 * 处理结构化的响应数据
 * @param config
 * @param response
 * @param defer
 */
API.prototype.processResponse = function processResponse (vars, config, defer, response) {
    var t = this;

    // 调用 didFetch 钩子函数
    config.didFetch(vars, config);

    // 非标准格式数据的预处理
    response = config.fit(response, vars);



    if (response.success) {
        // 数据处理
        var content = config.process(response.content, vars);

        var resolveDefer = function () {
            defer.resolve(content);
            event.fire('g.resolve', [content, config], config);
            event.fire(t.api.contextId + '.resolve', [content, config], config);
        };

        if (t.api.storageUseable) {
            t.api.storage.set(vars.queryString, content).then(function () {
                resolveDefer();
            })['catch'](function () {
                resolveDefer();
            });
        } else {
            resolveDefer();
        }
    } else {
        var error = extend$$1({
            message: '`success` is false, ' + t._path
        }, response.error);
        // NOTE response是只读的对象!!!
        defer.reject(error);
        event.fire('g.reject', [error, config]);
        event.fire(t.api.contextId + '.reject', [error, config]);
    }
};

/**
 * 发起Ajax请求
 * @param config {Object} 请求配置
 * @param defer {Object} defer对象
 * @param retryTime {undefined|Number} 如果没有重试 将是undefined值 见`createAPI`方法
 *                                 如果有重试 将是重试的当前次数 见`tryRequest`方法
 * @returns {Object} xhr对象实例
 */
API.prototype.sendAjax = function sendAjax (vars, config, defer) {
    var t = this;
    var url = config.mock ? config.mockUrl : config.url;

    return ajax({
        traditional: config.traditional,
        urlStamp: config.urlStamp,
        mark: vars.mark,
        useMark: config.mark,
        log: config.log,
        url: url,
        method: config.method,
        data: vars.data,
        header: config.header,
        withCredentials: config.withCredentials,
        // 强制约定json
        accept: 'json',
        success: function success(response/*, xhr*/) {
            t.processResponse(vars, config, defer, response);
        },
        error: function error(status) {
            // 如果跨域使用了自定义的header，且服务端没有配置允许对应的header，此处status为0，目前无法处理。
            var error = {
                status: status,
                message: ("Error(status " + status + ") in request for " + (vars.mark._api) + "(" + url + ")")
            };

            defer.reject(error);
            event.fire('g.reject', [error, config]);
            event.fire(t.api.contextId + '.reject', [error, config]);
        },
        complete: function complete(/*status, xhr*/) {
            if (vars.retryTime === undefined || vars.retryTime === config.retry) {
                //C.log('ajax complete');

                t.api.pending = FALSE$$1;
                t.api._requester = NULL$$1;
            }
            //console.log('__complete: pending:', config.pending, 'retryTime:', retryTime, Math.random());
        },
        postDataFormat: config.postDataFormat
    });
};

/**
 * 发起jsonp请求
 * @param vars {Object} 一次请求相关的私有数据
 * @param config {Object} 请求配置
 * @param defer {Object} defer对象
 * @param retryTime {undefined|Number} 如果没有重试 将是undefined值 见`createAPI`方法
 *                                 如果有重试 将是重试的当前次数 见`tryRequest`方法
 * @returns {Object} 带有abort方法的对象
 */
API.prototype.sendJSONP = function sendJSONP (vars, config, defer) {
    var t = this;
    var url = config.mock ? config.mockUrl : config.url;
    return jsonp({
        traditional: config.traditional,
        log: config.log,
        mark: vars.mark,
        useMark: config.mark,
        url: url,
        data: vars.data,
        urlStamp: config.urlStamp,
        flag: config.jsonpFlag,
        callbackName: config.jsonpCallbackName,
        success: function success(response) {
            t.processResponse(vars, config, defer, response);
        },
        error: function error() {
            var error = {
                message: ("Not accessable JSONP in request for " + (vars.mark._api) + "(" + url + ")")
            };

            defer.reject(error);
            event.fire('g.reject', [error, config]);
            event.fire(t.api.contextId + '.reject', [error, config]);
        },
        complete: function complete() {
            if (vars.retryTime === undefined || vars.retryTime === config.retry) {
                t.api.pending = FALSE$$1;
                t.api._requester = NULL$$1;
            }
        }
    });
};

/**
 * 关键词
 *     语意化的
 *     优雅的
 *     功能增强的
 *     底层隔离的
 */
var context = (function () {
    var count = 0;

    return function(contextId, options) {

        if (isString$$1(contextId)) {
            options = options || {};
        } else {
            options = contextId || {};
            contextId = 'c' + count++;
        }

        var storage = nattyStorage({
            type: 'variable',
            key: contextId
        });

        var ctx = {};

        ctx.api = storage.get();

        ctx._contextId = contextId;

        // 插件是不能覆盖的, 应该追加
        var plugins = [].concat(runtimeGlobalConfig.plugins || [], options.plugins || []);

        ctx._config = extend$$1({}, runtimeGlobalConfig, options, {
            plugins: plugins
        });

        /**
         * 创建api
         * @param namespace {String} optional
         * @param APIs {Object} 该`namespace`下的`api`配置
         */
        ctx.create = function(namespace, APIs) {
            var hasNamespace = arguments.length === 2 && isString$$1(namespace);

            if (!hasNamespace) {
                APIs = namespace;
            }

            for (var path in APIs) {
                storage.set(
                    hasNamespace ? namespace + '.' + path : path,
                    new API(
                        hasNamespace ? namespace + '.' + path : path,
                        runAsFn$$1(APIs[path]),
                        ctx._config,
                        contextId
                    ).api
                );
            }

            ctx.api = storage.get();
        };

        // 绑定上下文事件
        ctx.on = function(name, fn) {
            if (!isFunction$$1(fn)) { return; }
            event.on(ctx._contextId + '.' + name, fn);
            return ctx;
        };

        return ctx;
    }
})();

/**
 * 简易接口
 * @param options
 */
var nattyFetch = {};

nattyFetch.create = function (options) {
    return new API('nattyFetch', runAsFn$$1(options), defaultGlobalConfig, 'global').api;
};

extend$$1(nattyFetch, {
    onlyForModern: !true,
    version: '2.2.3',
    _util: util,
    _event: event,
    context: context,
    ajax: ajax,
    jsonp: jsonp,

    /**
     * 执行全局配置
     * @param options
     */
    setGlobal: function setGlobal(options) {
        runtimeGlobalConfig = extend$$1({}, defaultGlobalConfig, options);
        return this;
    },

    /**
     * 获取全局配置
     * @param property {String} optional
     * @returns {*}
     */
    getGlobal: function getGlobal(property) {
        return property ? runtimeGlobalConfig[property] : runtimeGlobalConfig;
    },

    // 绑定全局事件
    on: function on(name, fn) {
        if (!isFunction$$1(fn)) { return; }
        event.on('g.' + name, fn);
        return this;
    },

    /**
     * 插件名称空间
     */
    plugin: {
        loop: pluginLoop,
        soon: pluginSoon
    }
});

// 内部直接将运行时的全局配置初始化到默认值
nattyFetch.setGlobal(defaultGlobalConfig);

return nattyFetch;

})));
//# sourceMappingURL=natty-fetch.pc.js.map
