'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * CascadeSelectField Component for tingle
 * @author caoke.ck
 *
 * Copyright 2014-2016, Tingle Team.
 * All rights reserved.
 */
var React = require('react');
var classnames = require('classnames');

var Context = require('@ali/tingle-context');
var Slot = require('@ali/tingle-slot');
var Field = require('@ali/tingle-field');

var CascadeSelectField = function (_React$Component) {
    _inherits(CascadeSelectField, _React$Component);

    function CascadeSelectField(props) {
        _classCallCheck(this, CascadeSelectField);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(CascadeSelectField).call(this, props));

        var t = _this;

        // 数据格式化
        t.state = parseProps(props);
        t.state.confirmedValue = props.value ? t.state.value : [];
        return _this;
    }

    // 外部变更选中值


    _createClass(CascadeSelectField, [{
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            var t = this;
            t.setState(parseProps(nextProps));
        }
    }, {
        key: 'handleClick',
        value: function handleClick() {
            var t = this;
            !t.props.readOnly && t.refs.slot.show();
        }
    }, {
        key: 'handleChange',
        value: function handleChange(value) {
            var t = this;
            t.setState(parseState(value, t.props.options));
        }
    }, {
        key: 'handleConfirm',
        value: function handleConfirm(value) {
            var t = this;

            // 确认选中项目
            t.props.onSelect(value);
        }
    }, {
        key: 'handleCancel',
        value: function handleCancel() {
            var t = this;
            if (t.state.confirmedValue.length) {
                t.setState(parseState(t.state.confirmedValue, t.props.options));
            }
        }
    }, {
        key: 'render',
        value: function render() {
            var t = this;
            return React.createElement(
                Field,
                _extends({}, t.props, { icon: t.props.readOnly ? null : {
                        className: Context.prefixClass('cascade-select-field-icon'),
                        name: 'angle-right',
                        width: 26,
                        height: 26,
                        onClick: t.handleClick.bind(t)
                    },
                    className: classnames(Context.prefixClass('cascade-select-field'), _defineProperty({}, t.props.className, !!t.props.className)) }),
                React.createElement(
                    'div',
                    { onClick: t.handleClick.bind(t) },
                    !t.state.confirmedValue.length ? React.createElement(
                        'div',
                        { className: Context.prefixClass('omit cascade-select-field-placeholder') },
                        t.props.placeholder
                    ) : '',
                    React.createElement(
                        'div',
                        { className: Context.prefixClass('cascade-select-field-value FBH FBAC') },
                        React.createElement(
                            'span',
                            { className: classnames(Context.prefixClass('FB1 omit'), _defineProperty({}, Context.prefixClass('cascade-select-field-readonly'), !!t.props.readOnly)) },
                            t.props.formatter(t.state.confirmedValue)
                        )
                    )
                ),
                React.createElement(Slot, { ref: 'slot', title: t.props.label, confirmText: t.props.confirmText, cancelText: t.props.cancelText, data: t.state.options, value: t.state.value, onChange: t.handleChange.bind(t), onCancel: t.handleCancel.bind(t), onConfirm: t.handleConfirm.bind(t), columns: t.props.columns })
            );
        }
    }]);

    return CascadeSelectField;
}(React.Component);

CascadeSelectField.defaultProps = {
    options: [],
    value: [],
    formatter: function formatter(value) {
        return value.map(function (v) {
            return v.text;
        }).join('/');
    },
    onChange: function onChange() {},
    onSelect: function onSelect() {},
    readOnly: false,
    placeholder: '',
    columns: []
};

// http://facebook.github.io/react/docs/reusable-components.html
CascadeSelectField.propTypes = {
    className: React.PropTypes.string,
    label: React.PropTypes.string.isRequired,
    options: React.PropTypes.array,
    value: React.PropTypes.array,
    formatter: React.PropTypes.func,
    onChange: React.PropTypes.func,
    onSelect: React.PropTypes.func,
    readOnly: React.PropTypes.bool,
    placeholder: React.PropTypes.string,
    confirmText: React.PropTypes.string,
    cancelText: React.PropTypes.string,
    columns: React.PropTypes.array
};

CascadeSelectField.displayName = 'CascadeSelectField';

module.exports = CascadeSelectField;

function parseProps(props) {
    props = JSON.parse(JSON.stringify(props));
    var _props = props;
    var options = _props.options;
    var value = _props.value;

    var cursor = options;
    options = [];
    value = value || [];
    var confirmedValue = value.length ? value : [];

    var _loop = function _loop(deep) {
        var index = 0;
        options[deep] = cursor.map(function (o, i) {
            var option = {
                value: o.value,
                text: o.label
            };
            var val = value[deep];
            if ((typeof val === 'undefined' ? 'undefined' : _typeof(val)) == 'object' && 'value' in value[deep]) {
                val = value[deep].value;
            }
            if (o.value == val) {
                index = i;
                value[deep] = option;
            }
            return option;
        });
        cursor = cursor[index] ? cursor[index].children : null;
    };

    for (var deep = 0; cursor && deep < props.columns.length; deep++) {
        _loop(deep);
    }
    return {
        options: options,
        value: value,
        confirmedValue: confirmedValue
    };
}

function parseState(value, options) {
    var cursor = options;
    options = [];

    var _loop2 = function _loop2(deep) {
        var index = 0;
        options[deep] = cursor.map(function (o, i) {
            var option = {
                value: o.value,
                text: o.label
            };
            if (deep in value && o.value == value[deep].value) {
                index = i;
                value[deep] = option;
            }
            return option;
        });
        cursor = cursor[index] ? cursor[index].children : null;
    };

    for (var deep = 0; cursor; deep++) {
        _loop2(deep);
    }
    return {
        options: options,
        value: value
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkNhc2NhZGVTZWxlY3RGaWVsZC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7QUFPQSxJQUFNLFFBQVEsUUFBUSxPQUFSLENBQWQ7QUFDQSxJQUFNLGFBQWEsUUFBUSxZQUFSLENBQW5COztBQUVBLElBQU0sVUFBVSxRQUFRLHFCQUFSLENBQWhCO0FBQ0EsSUFBTSxPQUFPLFFBQVEsa0JBQVIsQ0FBYjtBQUNBLElBQU0sUUFBUSxRQUFRLG1CQUFSLENBQWQ7O0lBRU0sa0I7OztBQUVGLGdDQUFZLEtBQVosRUFBbUI7QUFBQTs7QUFBQSwwR0FDVCxLQURTOztBQUVmLFlBQUksU0FBSjs7QUFFQTtBQUNBLFVBQUUsS0FBRixHQUFVLFdBQVcsS0FBWCxDQUFWO0FBQ0EsVUFBRSxLQUFGLENBQVEsY0FBUixHQUF5QixNQUFNLEtBQU4sR0FBYyxFQUFFLEtBQUYsQ0FBUSxLQUF0QixHQUE4QixFQUF2RDtBQU5lO0FBT2xCOztBQUVEOzs7OztrREFDMEIsUyxFQUFXO0FBQ2pDLGdCQUFJLElBQUksSUFBUjtBQUNBLGNBQUUsUUFBRixDQUFXLFdBQVcsU0FBWCxDQUFYO0FBQ0g7OztzQ0FFYTtBQUNWLGdCQUFJLElBQUksSUFBUjtBQUNBLGFBQUMsRUFBRSxLQUFGLENBQVEsUUFBVCxJQUFxQixFQUFFLElBQUYsQ0FBTyxJQUFQLENBQVksSUFBWixFQUFyQjtBQUNIOzs7cUNBRVksSyxFQUFPO0FBQ2hCLGdCQUFJLElBQUksSUFBUjtBQUNBLGNBQUUsUUFBRixDQUFXLFdBQVcsS0FBWCxFQUFrQixFQUFFLEtBQUYsQ0FBUSxPQUExQixDQUFYO0FBQ0g7OztzQ0FFYSxLLEVBQU87QUFDakIsZ0JBQUksSUFBSSxJQUFSOztBQUVBO0FBQ0EsY0FBRSxLQUFGLENBQVEsUUFBUixDQUFpQixLQUFqQjtBQUNIOzs7dUNBRWM7QUFDWCxnQkFBSSxJQUFJLElBQVI7QUFDQSxnQkFBSSxFQUFFLEtBQUYsQ0FBUSxjQUFSLENB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QTNCLEVBQW1DO0FBQUEsZUFBMUIsSUFBMEI7QUFjbEM7QUFDRCxXQUFPO0FBQ0gsd0JBREc7QUFFSDtBQUZHLEtBQVA7QUFJSCIsImZpbGUiOiJDYXNjYWRlU2VsZWN0RmllbGQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENhc2NhZGVTZWxlY3RGaWVsZCBDb21wb25lbnQgZm9yIHRpbmdsZVxuICogQGF1dGhvciBjYW9rZS5ja1xuICpcbiAqIENvcHlyaWdodCAyMDE0LTIwMTYsIFRpbmdsZSBUZWFtLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuY29uc3QgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuY29uc3QgY2xhc3NuYW1lcyA9IHJlcXVpcmUoJ2NsYXNzbmFtZXMnKTtcblxuY29uc3QgQ29udGV4dCA9IHJlcXVpcmUoJ0BhbGkvdGluZ2xlLWNvbnRleHQnKTtcbmNvbnN0IFNsb3QgPSByZXF1aXJlKCdAYWxpL3RpbmdsZS1zbG90Jyk7XG5jb25zdCBGaWVsZCA9IHJlcXVpcmUoJ0BhbGkvdGluZ2xlLWZpZWxkJyk7XG5cbmNsYXNzIENhc2NhZGVTZWxlY3RGaWVsZCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG4gICAgICAgIGxldCB0ID0gdGhpcztcblxuICAgICAgICAvLyDmlbDmja7moLzlvI/ljJZcbiAgICAgICAgdC5zdGF0ZSA9IHBhcnNlUHJvcHMocHJvcHMpO1xuICAgICAgICB0LnN0YXRlLmNvbmZpcm1lZFZhbHVlID0gcHJvcHMudmFsdWUgPyB0LnN0YXRlLnZhbHVlIDogW107XG4gICAgfVxuXG4gICAgLy8g5aSW6YOo5Y+Y5pu06YCJ5Lit5YC8XG4gICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAgICAgbGV0IHQgPSB0aGlzO1xuICAgICAgICB0LnNldFN0YXRlKHBhcnNlUHJvcHMobmV4dFByb3BzKSk7XG4gICAgfVxuXG4gICAgaGFuZGxlQ2xpY2soKSB7XG4gICAgICAgIGxldCB0ID0gdGhpcztcbiAgICAgICAgIXQucHJvcHMucmVhZE9ubHkgJiYgdC5yZWZzLnNsb3Quc2hvdygpO1xuICAgIH1cblxuICAgIGhhbmRsZUNoYW5nZSh2YWx1ZSkge1xuICAgICAgICBsZXQgdCA9IHRoaXM7XG4gICAgICAgIHQuc2V0U3RhdGUocGFyc2VTdGF0ZSh2YWx1ZSwgdC5wcm9wcy5vcHRpb25zKSk7XG4gICAgfVxuXG4gICAgaGFuZGxlQ29uZmlybSh2YWx1ZSkge1xuICAgICAgICBsZXQgdCA9IHRoaXM7XG5cbiAgICAgICAgLy8g56Gu6K6k6YCJ5Lit6aG555uuXG4gICAgICAgIHQucHJvcHMub25TZWxlY3QodmFsdWUpO1xuICAgIH1cblxuICAgIGhhbmRsZUNhbmNlbCgpIHtcbiAgICAgICAgbGV0IHQgPSB0aGlzO1xuICAgICAgICBpZiAodC5zdGF0ZS5jb25maXJtZWRWYWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHQuc2V0U3RhdGUocGFyc2VTdGF0ZSh0LnN0YXRlLmNvbmZpcm1lZFZhbHVlLCB0LnByb3BzLm9wdGlvbnMpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHQgPSB0aGlzO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPEZpZWxkIHsuLi50LnByb3BzfSBpY29uPXt0LnByb3BzLnJlYWRPbmx5ID8gbnVsbCA6IHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBDb250ZXh0LnByZWZpeENsYXNzKCdjYXNjYWRlLXNlbGVjdC1maWVsZC1pY29uJyksXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdhbmdsZS1yaWdodCcsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiAyNixcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAyNixcbiAgICAgICAgICAgICAgICAgICAgb25DbGljazogdC5oYW5kbGVDbGljay5iaW5kKHQpXG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzbmFtZXMoQ29udGV4dC5wcmVmaXhDbGFzcygnY2FzY2FkZS1zZWxlY3QtZmllbGQnKSwge1xuICAgICAgICAgICAgICAgICAgICBbdC5wcm9wcy5jbGFzc05hbWVdOiAhIXQucHJvcHMuY2xhc3NOYW1lXG4gICAgICAgICAgICAgICAgfSl9PlxuICAgICAgICAgICAgICAgIDxkaXYgb25DbGljaz17dC5oYW5kbGVDbGljay5iaW5kKHQpfT5cbiAgICAgICAgICAgICAgICAgICAgeyF0LnN0YXRlLmNvbmZpcm1lZFZhbHVlLmxlbmd0aCA/IDxkaXYgY2xhc3NOYW1lPXtDb250ZXh0LnByZWZpeENsYXNzKCdvbWl0IGNhc2NhZGUtc2VsZWN0LWZpZWxkLXBsYWNlaG9sZGVyJyl9Pnt0LnByb3BzLnBsYWNlaG9sZGVyfTwvZGl2PiA6ICcnfVxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Q29udGV4dC5wcmVmaXhDbGFzcygnY2FzY2FkZS1zZWxlY3QtZmllbGQtdmFsdWUgRkJIIEZCQUMnKX0+XG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e2NsYXNzbmFtZXMoQ29udGV4dC5wcmVmaXhDbGFzcygnRkIxIG9taXQnKSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtDb250ZXh0LnByZWZpeENsYXNzKCdjYXNjYWRlLXNlbGVjdC1maWVsZC1yZWFkb25seScpXTogISF0LnByb3BzLnJlYWRPbmx5XG4gICAgICAgICAgICAgICAgICAgICAgICB9KX0+e3QucHJvcHMuZm9ybWF0dGVyKHQuc3RhdGUuY29uZmlybWVkVmFsdWUpfTwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPFNsb3QgcmVmPVwic2xvdFwiIHRpdGxlPXt0LnByb3BzLmxhYmVsfSBjb25maXJtVGV4dD17dC5wcm9wcy5jb25maXJtVGV4dH0gY2FuY2VsVGV4dD17dC5wcm9wcy5jYW5jZWxUZXh0fSBkYXRhPXt0LnN0YXRlLm9wdGlvbnN9IHZhbHVlPXt0LnN0YXRlLnZhbHVlfSBvbkNoYW5nZT17dC5oYW5kbGVDaGFuZ2UuYmluZCh0KX0gb25DYW5jZWw9e3QuaGFuZGxlQ2FuY2VsLmJpbmQodCl9IG9uQ29uZmlybT17dC5oYW5kbGVDb25maXJtLmJpbmQodCl9IGNvbHVtbnM9e3QucHJvcHMuY29sdW1uc30vPlxuICAgICAgICAgICAgPC9GaWVsZD5cbiAgICAgICAgKTtcbiAgICB9XG59XG5cbkNhc2NhZGVTZWxlY3RGaWVsZC5kZWZhdWx0UHJvcHMgPSB7XG4gICAgb3B0aW9uczogW10sXG4gICAgdmFsdWU6IFtdLFxuICAgIGZvcm1hdHRlcjogKHZhbHVlKSA9PiB2YWx1ZS5tYXAoKHYpID0+IHYudGV4dCkuam9pbignLycpLFxuICAgIG9uQ2hhbmdlOiAoKSA9PiB7fSxcbiAgICBvblNlbGVjdDogKCkgPT4ge30sXG4gICAgcmVhZE9ubHk6IGZhbHNlLFxuICAgIHBsYWNlaG9sZGVyOiAnJyxcbiAgICBjb2x1bW5zOiBbXVxufVxuXG4vLyBodHRwOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvcmV1c2FibGUtY29tcG9uZW50cy5odG1sXG5DYXNjYWRlU2VsZWN0RmllbGQucHJvcFR5cGVzID0ge1xuICAgIGNsYXNzTmFtZTogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBsYWJlbDogUmVhY3QuUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAgIG9wdGlvbnM6IFJlYWN0LlByb3BUeXBlcy5hcnJheSxcbiAgICB2YWx1ZTogUmVhY3QuUHJvcFR5cGVzLmFycmF5LFxuICAgIGZvcm1hdHRlcjogUmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25DaGFuZ2U6IFJlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIG9uU2VsZWN0OiBSZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICByZWFkT25seTogUmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgcGxhY2Vob2xkZXI6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgY29uZmlybVRleHQ6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgY2FuY2VsVGV4dDogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBjb2x1bW5zOiBSZWFjdC5Qcm9wVHlwZXMuYXJyYXlcbn1cblxuQ2FzY2FkZVNlbGVjdEZpZWxkLmRpc3BsYXlOYW1lID0gJ0Nhc2NhZGVTZWxlY3RGaWVsZCc7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FzY2FkZVNlbGVjdEZpZWxkO1xuXG5mdW5jdGlvbiBwYXJzZVByb3BzKHByb3BzKSB7XG4gICAgcHJvcHMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHByb3BzKSk7XG4gICAgbGV0IHsgb3B0aW9ucywgdmFsdWUgfSA9IHByb3BzO1xuICAgIGxldCBjdXJzb3IgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSBbXTtcbiAgICB2YWx1ZSA9IHZhbHVlIHx8IFtdO1xuICAgIGxldCBjb25maXJtZWRWYWx1ZSA9IHZhbHVlLmxlbmd0aCA/IHZhbHVlIDogW107XG4gICAgZm9yIChsZXQgZGVlcCA9IDA7IGN1cnNvciAmJiBkZWVwIDwgcHJvcHMuY29sdW1ucy5sZW5ndGg7IGRlZXArKykge1xuICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICBvcHRpb25zW2RlZXBdID0gY3Vyc29yLm1hcCgobywgaSkgPT4ge1xuICAgICAgICAgICAgbGV0IG9wdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogby52YWx1ZSxcbiAgICAgICAgICAgICAgICB0ZXh0OiBvLmxhYmVsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IHZhbCA9IHZhbHVlW2RlZXBdO1xuICAgICAgICAgICAgaWYgKCh0eXBlb2YgdmFsID09ICdvYmplY3QnKSAmJiAoJ3ZhbHVlJyBpbiB2YWx1ZVtkZWVwXSkpIHtcbiAgICAgICAgICAgICAgICB2YWwgPSB2YWx1ZVtkZWVwXS52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvLnZhbHVlID09IHZhbCkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICB2YWx1ZVtkZWVwXSA9IG9wdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvcHRpb247XG4gICAgICAgIH0pO1xuICAgICAgICBjdXJzb3IgPSBjdXJzb3JbaW5kZXhdID8gY3Vyc29yW2luZGV4XS5jaGlsZHJlbiA6IG51bGw7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBjb25maXJtZWRWYWx1ZVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIHBhcnNlU3RhdGUodmFsdWUsIG9wdGlvbnMpIHtcbiAgICBsZXQgY3Vyc29yID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0gW107XG4gICAgZm9yIChsZXQgZGVlcCA9IDA7IGN1cnNvcjsgZGVlcCsrKSB7XG4gICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgIG9wdGlvbnNbZGVlcF0gPSBjdXJzb3IubWFwKChvLCBpKSA9PiB7XG4gICAgICAgICAgICBsZXQgb3B0aW9uID0ge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBvLnZhbHVlLFxuICAgICAgICAgICAgICAgIHRleHQ6IG8ubGFiZWxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoKGRlZXAgaW4gdmFsdWUpICYmIG8udmFsdWUgPT0gdmFsdWVbZGVlcF0udmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgdmFsdWVbZGVlcF0gPSBvcHRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9uO1xuICAgICAgICB9KTtcbiAgICAgICAgY3Vyc29yID0gY3Vyc29yW2luZGV4XSA/IGN1cnNvcltpbmRleF0uY2hpbGRyZW4gOiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBvcHRpb25zLFxuICAgICAgICB2YWx1ZVxuICAgIH07XG59XG4iXSwic291cmNlUm9vdCI6Ii9zb3VyY2UvIn0=
