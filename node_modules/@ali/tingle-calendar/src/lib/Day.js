let classnames = require('classnames');
let i18n = require('../i18n');
let Context = require('@ali/tingle-context');
let prefixClass = Context.prefixClass;

// value 的格式：{startDate: '2016-01-02', startDateType: 'AM', endDate: '2016-01-03', endDateType: 'AM' }
class Day extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      currentDate: this.processValue(props).startDate, // 当前正在展示的面板上对应的时间，用以获取年和月的信息
      active: 'endDate'
    }
  }

  componentWillMount() {
    let t = this;
    t.locale = i18n[t.props.locale];
  }

  componentWillReceiveProps(nextProps) {
    let t = this;
    let {value} = t.props;
    let nextValue = nextProps.value;
    let {active} = t.state;
    let newState = {};
    if (new Date(value.startDate).getTime() !== new Date(nextValue.startDate).getTime()) {
      newState['active'] = 'startDate';
    }
    else {
      newState['active'] = 'endDate';
    }
    if (t.processValue().startDate.getTime() !== t.processValue(nextProps).startDate.getTime()) {
      newState['currentDate'] = t.processValue(nextProps).startDate;
    }

    t.setState(newState);
  }

  processValue(props) {
    let t = this;
    props = props || t.props;
    if (typeof props.value == 'object') {
      var {startDate, startDateType, endDate, endDateType} = props.value;
    }

    else {
      var startDate = props.value;
    }

    // 处理异常情况，当 endDate 存在且不等于 startDate 的情况下， startDateType 不可能为 'AM'
    if (endDate && new Date(startDate).getTime() !== new Date(endDate).getTime() && startDateType == 'AM') {
      startDateType = 'FULL';
    }
    return {
      startDate: new Date(startDate || 0),
      startDateType: startDateType || 'FULL',
      endDate: new Date(endDate || startDate || 0),
      endDateType: endDateType || 'FULL'
    }
  }

  handlePrev() {
    let t = this;
    let {currentDate} = t.state;
    t.setState({
      currentDate: new Date(currentDate.setMonth(currentDate.getMonth() - 1))
    })
  }

  handleNext() {
    let t = this;
    let {currentDate} = t.state;
    t.setState({
      currentDate: new Date(currentDate.setMonth(currentDate.getMonth() + 1))
    })
  }

  handleClick(date, e) {
    let t = this;
    
    //如果有onSelecting的方法，且其执行函数后值为false，则直接返回
    if(typeof t.props.onSelecting == 'function' && t.props.onSelecting(date, e) === false) {
      return;
    }

    let {singleMode} = t.props;
    let {startDate, startDateType, endDate, endDateType} = t.props.value;
    let status = 0;
    // 先判断目前是一点状态还是两点状态，如果 startDate != endDate 则为两点状态，
    // 否则相等则为一点、startDate 为 0 则为0点状态
    if (!!startDate) {
      // 如果是单选模式，则 status 总为 2
      if (!!endDate && new Date(endDate).getTime() !== new Date(startDate).getTime() || singleMode) {
        status = 2
      }
      else {
        status = 1;
      }
    }


    let newStartDate = '';
    let newEndDate = '';
    let newStartDateType = 'FULL';
    let newEndDateType = 'FULL';
    if (status == 0) {
      newStartDate = date.getTime();
    }
    else if (status == 1) {
      // 判断点击的时间和开始时间的大小，以决定谁是新的开始时间。
      if (date.getTime() >= new Date(startDate).getTime()) {
        newStartDate = startDate;
        newEndDate = date.getTime();
        newStartDateType = startDateType;

      }
      else {
        newStartDate = date.getTime();
        newEndDate = startDate;
        newEndDateType = startDateType;
      }
    }
    else {
      newStartDate = date.getTime();
    }

    t.props.onChange({
      startDate: newStartDate,
      startDateType: newStartDateType,
      endDate: newEndDate,
      endDateType: newEndDateType
    })

  }

  handleTypeClick(type, e) {
    let t = this;
    let value = (typeof t.props.value == "string") ? {startDate: t.props.value} : t.props.value;
    let {startDate, startDateType, endDate, endDateType} = value;
    let status = 0;
    let {active} = t.state;
    // 先判断目前是一点状态还是两点状态，如果 startDate != endDate 则为两点状态，
    // 否则相等则为一点、startDate 不存在则为 0 点状态
    if (!!startDate) {
      if (!!endDate && new Date(endDate).getTime() !== new Date(startDate).getTime()) {
        status = 2
      }
      else {
        status = 1;
      }
    }

    let newStartDateType = "FULL";
    let newEndDateType = "FULL";

    if (status == 2) {
      if (active == 'startDate') {
        newStartDateType = type;
        newEndDateType = endDateType;
      }
      else {
        newStartDateType = startDateType;
        newEndDateType = type;
      }
    }
    else {
      newStartDateType = type;
      newEndDateType = type;
    }

    t.props.onChange({
      startDate: startDate,
      startDateType: newStartDateType,
      endDate: endDate,
      endDateType: newEndDateType
    })

  }

  handleTitleClick(e) {
    if (this.props.singleMode) {
      this.props.onTitleClick(e);
    }
  }

  /**
   * 当前时间是否在被选中的范围
   * @param {Date} date 当前时间
   * @param {Object} 由 processValue 导出的时间范围
   */
  isInRange(date, value) {

    return ( date.getTime() >= value.startDate.getTime() ) && ( date.getTime() <= value.endDate.getTime() );
  }

  getType(date, value) {
    let type = '';
    ['FULL', 'AM', 'PM'].forEach((item, index) => {
      if ( (date.getTime() == value.startDate.getTime() && new RegExp(item, 'i').test(value.startDateType)) ||
           (date.getTime() == value.endDate.getTime() && new RegExp(item, 'i').test(value.endDateType)) ) {
        type = item;
      }
    })
    return type;
  }

  renderDate(date, value) {
    let t = this;
    // TODO: tStatus 假休班
    // 只有开始和结束的日子可能出现上午和下午
    let type = t.getType(date, value);
    let now = new Date();
    let currentDate = t.state.currentDate
    let cls = classnames({
      [prefixClass('FB1 tap op')]: true,
      [prefixClass('now')]: now.getTime() == date.getTime(),
      [prefixClass('selected')]: t.isInRange(date, value),
      [prefixClass('AM')]: type == 'AM',
      [prefixClass('PM')]: type == 'PM',
      [prefixClass('prev-month')]: (date.getMonth() < currentDate.getMonth() && date.getYear() === currentDate.getYear())
        || date.getYear() < currentDate.getYear(),
      [prefixClass('next-month')]: (date.getMonth() > currentDate.getMonth() && date.getYear() === currentDate.getYear())
        || date.getYear() > currentDate.getYear(),
      [prefixClass('weekend')]: date.getDay() === 6 || date.getDay() === 0,
      [t.handleExtraClass(date, value)]: true
    });
    //在这里添加新功能，确定不可用日期
    let dateContent = <div key={date.getTime()} className={cls} onClick={t.handleClick.bind(t, new Date(date))}>
      <div className={prefixClass('date-point')}>
        {date.getDate()}
      </div>
      {t.props.showHalfDay ?
        <div className={classnames({ [prefixClass('date-tip')]: true })}>
          {t.props.showHalfDay ? t.locale['dayTipMap'][type] : ""}
        </div> : ''}
    </div>
    return dateContent;
  }

  //给“天”的展示项目添加新的样式
  handleExtraClass(date, value) {
    //如果添加的是一个字符串
    if(typeof this.props.extraClass == 'string') {
      return this.props.extraClass;
    }
    else if(typeof this.props.extraClass == 'function') {
      return this.props.extraClass(date, value) || '';
    }
    return '';
  }

  renderDatePanel(value) {
    let t = this;
    let dateArrInAWeek = [];
    let weekArr = [];
    let flexBoxKey = 0;
    let {currentDate} = t.state;
    let currentYear = currentDate.getFullYear();
    let currentMonth = currentDate.getMonth();
    let {calendarCode} = t.props;
    let now = new Date();
    let firstDateInStartMonth = new Date(new Date(currentDate).setDate(1));
    let changedDate =  new Date(new Date(currentDate).setDate(1)); // 用于当月的循环复制
    let firstDayInStartMonth = firstDateInStartMonth.getDay();
    let firstDateShownInPanel = new Date(firstDateInStartMonth.setDate(firstDateInStartMonth.getDate() - firstDayInStartMonth));

    //计算上个月剩余补充天数
    for (let i = 0; i < firstDayInStartMonth; i++) {
      let changedDate = new Date(firstDateShownInPanel);
      let date = new Date(changedDate.setDate(changedDate.getDate() + i));
      dateArrInAWeek.push(t.renderDate(date, value));
    }

    // 计算当前月天数

    while (changedDate.getMonth() == currentMonth) {
      flexBoxKey++;
      // 判断 dateArrInAWeek 数组是否已满 7 个，若满则推入 weekArr 数组
      if (dateArrInAWeek.length == 7) {
        weekArr.push(<div key={currentMonth + flexBoxKey} className={prefixClass('FBH')}>{dateArrInAWeek}</div>);
        dateArrInAWeek = [];
      }
      dateArrInAWeek.push(t.renderDate(new Date(changedDate), value));
      changedDate.setDate(changedDate.getDate() + 1);

    }

    // 计算下个月剩余补充天数，如果下个月第一天恰好是周日，那么就没有必要渲染下个月了
    // 把最后一个 dateArrInAWeek 数组推进 weekArr 数组
    if (changedDate.getDay() == 0) {
      weekArr.push(<div key={"last"} className={prefixClass('FBH')}>{dateArrInAWeek}</div>);
    }
    else {
      let delta = 7 - changedDate.getDay();
      for (let i = 0; i < delta; i++) {
        dateArrInAWeek.push(t.renderDate(new Date(changedDate), value));
        changedDate.setDate(changedDate.getDate() + 1)
      }
      weekArr.push(<div key={"last"} className={prefixClass('FBH')}>{dateArrInAWeek}</div>)
    }

    return weekArr;
  }

  renderHalfDayButton(date, value) {
    if (!this.props.showHalfDay) return;

    let t = this;
    let {active} = t.state;
    let type = t.getType(date, value);
    let am = <div key="tMorning" className={prefixClass("day morning tap op ") + (type == 'AM' ? 'now' : '' )}
                  onClick={t.handleTypeClick.bind(t, 'AM')}>
              <span>{t.locale['dayTipMap']['AM']}</span>
            </div>;
    let pm = <div key="tAfternoon" className={prefixClass("day afternoon tap op ") + (type == 'PM' ? 'now' : '' )}
                onClick={t.handleTypeClick.bind(t, 'PM')}>
              <span>{t.locale['dayTipMap']['PM']}</span>
            </div>;
    let full = <div key="tFullDay" className={prefixClass("day fullday tap op ") + (type == 'FULL' ? 'now' : '' )}
                   onClick={t.handleTypeClick.bind(t, 'FULL')}>
                <span>{t.locale['dayTipMap']['FULL']}</span>
              </div>

    // 处理被选中的日期，需判断当前是起点还是终点，若 开始时间 == 结束时间 则是起点

    //是否显示上午、下午
    if (value.startDate.getTime() === value.endDate.getTime()) {
      return [full, am, pm];
    }
    else {
      if (active == 'endDate') {
        return [full, am]
      }
      else {
        return [full, pm]
      }
    }
  }

  renderTitle(value) {
    let t = this;
    let {currentDate} = t.state;
    let str = '';
    switch (t.props.locale) {
      case 'zh-cn':
        str = currentDate.getFullYear() + '年' + (currentDate.getMonth() + 1) + '月';
        break;
      case 'en':
        str = t.locale['monthTitle'][currentDate.getMonth()] + ' ' + currentDate.getFullYear();
        break;
    }
    return str;
  }

  renderHalfDay() {
    let t = this;
    let value = t.processValue();
    let {active} = t.state;
    let left = t.renderHalfDayButton(value[active], value);
    let selected = value[active].getDate();
    return  <div className={classnames({
                [prefixClass("half-wrap FBH FBAC")]: true
            })}>
              <div className={classnames({
                [prefixClass("selected-day")]: true,
                [prefixClass("DN")]: !t.props.showHalfDay
              })}>{selected}</div>
              {left}
              <div className={prefixClass("FB1")}></div>
            </div>
  }

  render() {
    let t = this;
    let value = t.processValue();
    let clearButton = '';
    let ret = '';
    let {show, className, singleMode, showHalfDay} = t.props;

    if (show) {
      ret = this.renderDatePanel(value);
    }

    return (
        <div className={prefixClass('month-panel')}>
          <div className={prefixClass('tool FBH FBAC')}>
            <div className={prefixClass('FB1')}></div>
            <div className={prefixClass('btn prev-month tap op')} onClick={t.handlePrev.bind(t)}>&lt;</div>
            <span className={prefixClass('text')} onClick={t.handleTitleClick.bind(t)}>{this.renderTitle(value)}</span>
            <div className={prefixClass('btn next-month tap op')} onClick={t.handleNext.bind(t)}>&gt;</div>
            <div className={prefixClass('FB1')}></div>
          </div>
          <div className={prefixClass('week FBH')}>
            {
              t.locale['weekTitle'].map(function (item, index) {
                return <div className={prefixClass('FB1 FBAC')} key={index}>{item}</div>
              })
            }
          </div>
          <div className={prefixClass('month')}>
            {ret}
          </div>
          {t.props.showHalfDay && t.renderHalfDay()}
        </div>
    );
  }

}


Day.propTypes = {
  show: React.PropTypes.bool, // 是否显示
  singleMode: React.PropTypes.bool, // 是否是单选模式
  showHalfDay: React.PropTypes.bool, // 是否显示半天
  calendarCode: React.PropTypes.object, // 后端传来的 code
  value: React.PropTypes.oneOfType([ // 默认值
    React.PropTypes.string,
    React.PropTypes.object
  ]),
  extraClass: React.PropTypes.oneOfType([ // 默认值
    React.PropTypes.string,
    React.PropTypes.func
  ]),
  onSelecting: React.PropTypes.func, //当某一天被点击是触发事件，如果其值为false则不执行
  locale: React.PropTypes.string, // 国际化语言
  onChange: React.PropTypes.func, // value 变化时触发的回调
  onTitleClick: React.PropTypes.func // 点击标题时触发的回调，用于切换面板
}

Day.defaultProps = {
  show: true,
  singleMode: true,
  showHalfDay: true,
  locale: 'zh-cn',
  calendarCode: {},
  onChange: () => {},
  onSelecting: () => {},
  onTitleClick: () => {},
  extraClass: ''
}

Day.displayName = "Day";

module.exports = Day;
