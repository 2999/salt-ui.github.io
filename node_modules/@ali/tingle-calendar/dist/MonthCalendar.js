'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var classnames = require('classnames');
var deepcopy = require('deepcopy');
var deepEqual = require('deep-equal');
var i18n = require('./i18n');

var Layer = require('@ali/tingle-layer');
var Formatter = require('uxcore-formatter');
var Month = require('./lib/Month');
var Year = require('./lib/Year');

var Context = require('@ali/tingle-context');
var prefixClass = Context.prefixClass;

var MonthCalendar = function (_React$Component) {
  _inherits(MonthCalendar, _React$Component);

  function MonthCalendar(props) {
    _classCallCheck(this, MonthCalendar);

    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(MonthCalendar).call(this, props));

    _this.value = deepcopy(props.value);
    _this.state = {
      value: deepcopy(props.value),
      panel: 'month'
    };
    return _this;
  }

  _createClass(MonthCalendar, [{
    key: 'componentWillMount',
    value: function componentWillMount() {
      var t = this;
      t.locale = i18n[t.props.locale];
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      var t = this;
      if (!deepEqual(nextProps.value, t.value)) {
        t.value = deepcopy(nextProps.value);
        t.setState({
          value: deepcopy(nextProps.value)
        });
      }
    }
  }, {
    key: 'handleChange',
    value: function handleChange(value) {
      var t = this;
      var newState = {
        value: value
      };
      if (t.state.panel == 'year') {
        newState['panel'] = 'month';
      }
      t.setState(newState);
    }
  }, {
    key: 'handleCanel',
    value: function handleCanel() {
      var t = this;
      t.props.onCancel();
    }
  }, {
    key: 'handleClear',
    value: function handleClear() {
      var t = this;
      t.setState({
        value: deepcopy(t.props.value)
      });
    }
  }, {
    key: 'handleOk',
    value: function handleOk() {
      var t = this;
      var _t$state = t.state;
      var startDate = _t$state.startDate;
      var endDate = _t$state.endDate;

      if (!!t.state.value.startDate) {
        t.props.onOk(t.state.value);
      }
    }
  }, {
    key: 'handlePanelChange',
    value: function handlePanelChange() {
      var t = this;
      var panel = t.state.panel;

      if (panel == 'month') {
        panel = 'year';
      }
      t.setState({
        panel: panel
      });
    }
  }, {
    key: 'renderTopPanel',
    value: function renderTopPanel() {
      return React.createElement(
        'div',
        { className: classnames(_defineProperty({}, prefixClass("top-panel"), true)) },
        React.createElement(
          'span',
          { className: prefixClass("top-panel-cancel"), onClick: this.handleCanel.bind(this) },
          this.locale['button']['cancel']
        ),
        React.createElement(
          'span',
          { className: prefixClass("top-panel-title") },
          this.props.topPanelTitle || '选择时间'
        ),
        React.createElement(
          'span',
          { className: prefixClass("top-panel-confirm"), onClick: this.handleOk.bind(this) },
          this.locale['button']['confirm']
        )
      );
    }
  }, {
    key: 'renderPanel',
    value: function renderPanel() {
      var t = this;
      var _t$state2 = t.state;
      var value = _t$state2.value;
      var panel = _t$state2.panel;
      var _t$props = t.props;
      var singleMode = _t$props.singleMode;
      var locale = _t$props.locale;
      var showHalfDay = _t$props.showHalfDay;

      var panelProps = {
        value: value,
        onChange: t.handleChange.bind(t),
        singleMode: singleMode,
        locale: locale,
        showHalfDay: showHalfDay,
        onTitleClick: t.handlePanelChange.bind(t)
      };
      if (panel == 'month') {
        return React.createElement(Month, panelProps);
      } else {
        panelProps['singleMode'] = true;
        return React.createElement(Year, panelProps);
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var _classnames2;

      var t = this;
      var _t$props2 = t.props;
      var visible = _t$props2.visible;
      var className = _t$props2.className;
      var singleMode = _t$props2.singleMode;

      var button = t.locale['button'];

      // Calculate the height of the current container
      var clientHeight = document.documentElement.clientHeight;
      var height = 230;
      !!t.props.showTopPanel && (height += 44);
      !!t.props.showHalfDay && (height += 120);

      return React.createElement(
        Layer,
        { visible: visible },
        React.createElement(
          'div',
          { className: prefixClass("calendar-container"), style: {
              height: clientHeight,
              // Scale the view to ensure user can see the whole widgit 
              // on the small screen device
              transform: height >= clientHeight ? 'scale(' + ((clientHeight / height).toFixed(3) - 0.15) + ')' : ''
            } },
          React.createElement(
            'div',
            { className: classnames((_classnames2 = {}, _defineProperty(_classnames2, prefixClass("calendar"), true), _defineProperty(_classnames2, className, !!className), _classnames2)), style: {
                display: visible ? 'block' : 'none',
                height: height
              } },
            t.props.showTopPanel && t.renderTopPanel(),
            t.renderPanel()
          )
        )
      );
    }
  }]);

  return MonthCalendar;
}(React.Component);

MonthCalendar.displayName = "MonthCalendar";
MonthCalendar.defaultProps = {
  locale: 'zh-cn',
  onCancel: function onCancel() {},
  onOk: function onOk() {},
  value: {
    startDate: new Date().getTime(),
    startDateType: 'FULL',
    endDate: new Date().getTime(),
    endDateType: 'FULL'
  },
  showTopPanel: true,
  singleMode: false
};
MonthCalendar.propTypes = {
  value: React.PropTypes.object,
  locale: React.PropTypes.string,
  onCancel: React.PropTypes.func,
  onOk: React.PropTypes.func,
  visible: React.PropTypes.bool,
  singleMode: React.PropTypes.bool
};

module.exports = MonthCalendar;
//# sourceMappingURL=data:application/json;base64,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O0FBR0wsYUFBUyxJQUFJLElBQUosR0FBVyxPQUFYLEVBSEo7QUFJTCxpQkFBYTtBQUpSLEdBTm9CO0FBWTNCLGdCQUFjLElBWmE7QUFhM0IsY0FBWTtBQWJlLENBQTdCO0FBZUEsY0FBYyxTQUFkLEdBQTBCO0FBQ3hCLFNBQU8sTUFBTSxTQUFOLENBQWdCLE1BREM7QUFFeEIsVUFBUSxNQUFNLFNBQU4sQ0FBZ0IsTUFGQTtBQUd4QixZQUFVLE1BQU0sU0FBTixDQUFnQixJQUhGO0FBSXhCLFFBQU0sTUFBTSxTQUFOLENBQWdCLElBSkU7QUFLeEIsV0FBUyxNQUFNLFNBQU4sQ0FBZ0IsSUFMRDtBQU14QixjQUFZLE1BQU0sU0FBTixDQUFnQjtBQU5KLENBQTFCOztBQVNBLE9BQU8sT0FBUCxHQUFpQixhQUFqQiIsImZpbGUiOiJNb250aENhbGVuZGFyLmpzIiwic291cmNlc0NvbnRlbnQiOlsibGV0IGNsYXNzbmFtZXMgPSByZXF1aXJlKCdjbGFzc25hbWVzJyk7XG5sZXQgZGVlcGNvcHkgPSByZXF1aXJlKCdkZWVwY29weScpO1xubGV0IGRlZXBFcXVhbCA9IHJlcXVpcmUoJ2RlZXAtZXF1YWwnKTtcbmxldCBpMThuID0gcmVxdWlyZSgnLi9pMThuJyk7XG5cbmxldCBMYXllciA9IHJlcXVpcmUoJ0BhbGkvdGluZ2xlLWxheWVyJyk7XG5sZXQgRm9ybWF0dGVyID0gcmVxdWlyZSgndXhjb3JlLWZvcm1hdHRlcicpO1xubGV0IE1vbnRoID0gcmVxdWlyZSgnLi9saWIvTW9udGgnKTtcbmxldCBZZWFyID0gcmVxdWlyZSgnLi9saWIvWWVhcicpO1xuXG5sZXQgQ29udGV4dCA9IHJlcXVpcmUoJ0BhbGkvdGluZ2xlLWNvbnRleHQnKTtcbmxldCBwcmVmaXhDbGFzcyA9IENvbnRleHQucHJlZml4Q2xhc3M7XG5cbmNsYXNzIE1vbnRoQ2FsZW5kYXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLnZhbHVlID0gZGVlcGNvcHkocHJvcHMudmFsdWUpO1xuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICB2YWx1ZTogZGVlcGNvcHkocHJvcHMudmFsdWUpLFxuICAgICAgcGFuZWw6ICdtb250aCdcbiAgICB9XG4gIH1cblxuICBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgbGV0IHQgPSB0aGlzO1xuICAgIHQubG9jYWxlID0gaTE4blt0LnByb3BzLmxvY2FsZV07XG4gIH1cblxuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgIGxldCB0ID0gdGhpcztcbiAgICBpZiAoIWRlZXBFcXVhbChuZXh0UHJvcHMudmFsdWUsIHQudmFsdWUpKSB7XG4gICAgICB0LnZhbHVlID0gZGVlcGNvcHkobmV4dFByb3BzLnZhbHVlKTtcbiAgICAgIHQuc2V0U3RhdGUoe1xuICAgICAgICB2YWx1ZTogZGVlcGNvcHkobmV4dFByb3BzLnZhbHVlKVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBoYW5kbGVDaGFuZ2UodmFsdWUpIHtcbiAgICBsZXQgdCA9IHRoaXM7XG4gICAgbGV0IG5ld1N0YXRlID0ge1xuICAgICAgdmFsdWU6IHZhbHVlXG4gICAgfTtcbiAgICBpZiAodC5zdGF0ZS5wYW5lbCA9PSAneWVhcicpIHtcbiAgICAgIG5ld1N0YXRlWydwYW5lbCddID0gJ21vbnRoJztcbiAgICB9XG4gICAgdC5zZXRTdGF0ZShuZXdTdGF0ZSk7XG4gIH1cblxuICBoYW5kbGVDYW5lbCgpIHtcbiAgICBsZXQgdCA9IHRoaXM7XG4gICAgdC5wcm9wcy5vbkNhbmNlbCgpXG4gIH1cblxuICBoYW5kbGVDbGVhcigpIHtcbiAgICBsZXQgdCA9IHRoaXM7XG4gICAgdC5zZXRTdGF0ZSh7XG4gICAgICB2YWx1ZTogZGVlcGNvcHkodC5wcm9wcy52YWx1ZSlcbiAgICB9KVxuICB9XG5cbiAgaGFuZGxlT2soKSB7XG4gICAgbGV0IHQgPSB0aGlzO1xuICAgIGxldCB7c3RhcnREYXRlLCBlbmREYXRlfSA9IHQuc3RhdGU7XG4gICAgaWYgKCEhdC5zdGF0ZS52YWx1ZS5zdGFydERhdGUpIHtcbiAgICAgIHQucHJvcHMub25Payh0LnN0YXRlLnZhbHVlKTtcbiAgICB9XG4gIH1cblxuICBoYW5kbGVQYW5lbENoYW5nZSgpIHtcbiAgICBsZXQgdCA9IHRoaXM7XG4gICAgbGV0IHtwYW5lbH0gPSB0LnN0YXRlO1xuICAgIGlmIChwYW5lbCA9PSAnbW9udGgnKSB7XG4gICAgICBwYW5lbCA9ICd5ZWFyJztcbiAgICB9XG4gICAgdC5zZXRTdGF0ZSh7XG4gICAgICBwYW5lbDogcGFuZWxcbiAgICB9KVxuICB9XG5cbiAgcmVuZGVyVG9wUGFuZWwoKSB7XG4gICAgcmV0dXJuIDxkaXYgY2xhc3NOYW1lPXtjbGFzc25hbWVzKHtbcHJlZml4Q2xhc3MoXCJ0b3AtcGFuZWxcIildOiB0cnVlfSl9PlxuICAgICAgPHNwYW4gY2xhc3NOYW1lPXtwcmVmaXhDbGFzcyhcInRvcC1wYW5lbC1jYW5jZWxcIil9IG9uQ2xpY2s9e3RoaXMuaGFuZGxlQ2FuZWwuYmluZCh0aGlzKX0+e3RoaXMubG9jYWxlWydidXR0b24nXVsnY2FuY2VsJ119PC9zcGFuPlxuICAgICAgPHNwYW4gY2xhc3NOYW1lPXtwcmVmaXhDbGFzcyhcInRvcC1wYW5lbC10aXRsZVwiKX0+e3RoaXMucHJvcHMudG9wUGFuZWxUaXRsZSB8fCAn6YCJ5oup5pe26Ze0J308L3NwYW4+XG4gICAgICA8c3BhbiBjbGFzc05hbWU9e3ByZWZpeENsYXNzKFwidG9wLXBhbmVsLWNvbmZpcm1cIil9IG9uQ2xpY2s9e3RoaXMuaGFuZGxlT2suYmluZCh0aGlzKX0+e3RoaXMubG9jYWxlWydidXR0b24nXVsnY29uZmlybSddfTwvc3Bhbj5cbiAgICA8L2Rpdj5cbiAgfVxuXG4gIHJlbmRlclBhbmVsKCkge1xuICAgIGxldCB0ID0gdGhpcztcbiAgICBsZXQge3ZhbHVlLCBwYW5lbH0gPSB0LnN0YXRlO1xuICAgIGxldCB7c2luZ2xlTW9kZSwgbG9jYWxlLCBzaG93SGFsZkRheX0gPSB0LnByb3BzO1xuICAgIGxldCBwYW5lbFByb3BzID0ge1xuICAgICAgdmFsdWU6IHZhbHVlLCBcbiAgICAgIG9uQ2hhbmdlOiB0LmhhbmRsZUNoYW5nZS5iaW5kKHQpLCBcbiAgICAgIHNpbmdsZU1vZGU6IHNpbmdsZU1vZGUsIFxuICAgICAgbG9jYWxlOiBsb2NhbGUsIFxuICAgICAgc2hvd0hhbGZEYXk6IHNob3dIYWxmRGF5LFxuICAgICAgb25UaXRsZUNsaWNrOiB0LmhhbmRsZVBhbmVsQ2hhbmdlLmJpbmQodClcbiAgICB9O1xuICAgIGlmIChwYW5lbCA9PSAnbW9udGgnKSB7XG4gICAgICByZXR1cm4gPE1vbnRoIHsuLi5wYW5lbFByb3BzfS8+XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcGFuZWxQcm9wc1snc2luZ2xlTW9kZSddID0gdHJ1ZTtcbiAgICAgIHJldHVybiA8WWVhciB7Li4ucGFuZWxQcm9wc30vPlxuICAgIH1cbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBsZXQgdCA9IHRoaXM7XG4gICAgbGV0IHt2aXNpYmxlLCBjbGFzc05hbWUsIHNpbmdsZU1vZGV9ID0gdC5wcm9wcztcbiAgICBsZXQgYnV0dG9uID0gdC5sb2NhbGVbJ2J1dHRvbiddO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBoZWlnaHQgb2YgdGhlIGN1cnJlbnQgY29udGFpbmVyXG4gICAgbGV0IGNsaWVudEhlaWdodCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHRcbiAgICBsZXQgaGVpZ2h0ID0gMjMwXG4gICAgISF0LnByb3BzLnNob3dUb3BQYW5lbCAmJiAoaGVpZ2h0ICs9IDQ0KTsgXG4gICAgISF0LnByb3BzLnNob3dIYWxmRGF5ICYmIChoZWlnaHQgKz0gMTIwKTsgXG5cbiAgICByZXR1cm4gKFxuICAgICAgPExheWVyIHZpc2libGU9e3Zpc2libGV9PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17cHJlZml4Q2xhc3MoXCJjYWxlbmRhci1jb250YWluZXJcIil9IHN0eWxlPXt7XG4gICAgICAgICAgaGVpZ2h0OiBjbGllbnRIZWlnaHQsXG4gICAgICAgICAgLy8gU2NhbGUgdGhlIHZpZXcgdG8gZW5zdXJlIHVzZXIgY2FuIHNlZSB0aGUgd2hvbGUgd2lkZ2l0IFxuICAgICAgICAgIC8vIG9uIHRoZSBzbWFsbCBzY3JlZW4gZGV2aWNlXG4gICAgICAgICAgdHJhbnNmb3JtOiBoZWlnaHQgPj0gY2xpZW50SGVpZ2h0ID8gJ3NjYWxlKCcgKyAoKGNsaWVudEhlaWdodCAvIGhlaWdodCkudG9GaXhlZCgzKSAtIDAuMTUgKSsgJyknIDogJydcbiAgICAgICAgfX0+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjbGFzc25hbWVzKHtcbiAgICAgICAgICAgICAgICAgICAgW3ByZWZpeENsYXNzKFwiY2FsZW5kYXJcIildOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBbY2xhc3NOYW1lXTogISFjbGFzc05hbWVcbiAgICAgICAgICAgICAgICB9KX0gc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogdmlzaWJsZSA/ICdibG9jaycgOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgICAgICAgICAgfX0+XG4gICAgICAgICAge3QucHJvcHMuc2hvd1RvcFBhbmVsICYmIHQucmVuZGVyVG9wUGFuZWwoKX1cbiAgICAgICAgICB7dC5yZW5kZXJQYW5lbCgpfVxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L0xheWVyPlxuICAgIClcbiAgfVxufVxuXG5Nb250aENhbGVuZGFyLmRpc3BsYXlOYW1lID0gXCJNb250aENhbGVuZGFyXCI7XG5Nb250aENhbGVuZGFyLmRlZmF1bHRQcm9wcyA9IHtcbiAgbG9jYWxlOiAnemgtY24nLFxuICBvbkNhbmNlbDogKCkgPT4ge1xuICB9LFxuICBvbk9rOiAoKSA9PiB7XG4gIH0sXG4gIHZhbHVlOiB7XG4gICAgc3RhcnREYXRlOiBuZXcgRGF0ZSgpLmdldFRpbWUoKSxcbiAgICBzdGFydERhdGVUeXBlOiAnRlVMTCcsXG4gICAgZW5kRGF0ZTogbmV3IERhdGUoKS5nZXRUaW1lKCksXG4gICAgZW5kRGF0ZVR5cGU6ICdGVUxMJ1xuICB9LFxuICBzaG93VG9wUGFuZWw6IHRydWUsXG4gIHNpbmdsZU1vZGU6IGZhbHNlXG59O1xuTW9udGhDYWxlbmRhci5wcm9wVHlwZXMgPSB7XG4gIHZhbHVlOiBSZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICBsb2NhbGU6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gIG9uQ2FuY2VsOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgb25PazogUmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gIHZpc2libGU6IFJlYWN0LlByb3BUeXBlcy5ib29sLFxuICBzaW5nbGVNb2RlOiBSZWFjdC5Qcm9wVHlwZXMuYm9vbFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBNb250aENhbGVuZGFyO1xuIl0sInNvdXJjZVJvb3QiOiIvc291cmNlLyJ9
