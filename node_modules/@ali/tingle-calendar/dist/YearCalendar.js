'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var classnames = require('classnames');
var deepcopy = require('deepcopy');
var deepEqual = require('deep-equal');
var i18n = require('./i18n');

var Layer = require('@ali/tingle-layer');
var Formatter = require('uxcore-formatter');
var Year = require('./lib/Year');
var Context = require('@ali/tingle-context');

var prefixClass = Context.prefixClass;

var YearCalendar = function (_React$Component) {
  _inherits(YearCalendar, _React$Component);

  function YearCalendar(props) {
    _classCallCheck(this, YearCalendar);

    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(YearCalendar).call(this, props));

    _this.value = deepcopy(props.value);
    _this.state = {
      value: deepcopy(props.value),
      panel: 'year'
    };
    return _this;
  }

  _createClass(YearCalendar, [{
    key: 'componentWillMount',
    value: function componentWillMount() {
      var t = this;
      t.locale = i18n[t.props.locale];
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      var t = this;
      if (!deepEqual(nextProps.value, t.value)) {
        t.value = deepcopy(nextProps.value);
        t.setState({
          value: deepcopy(nextProps.value)
        });
      }
    }
  }, {
    key: 'handleChange',
    value: function handleChange(value) {
      var t = this;
      t.setState({
        value: value
      });
    }
  }, {
    key: 'handleCanel',
    value: function handleCanel() {
      var t = this;
      t.props.onCancel();
    }
  }, {
    key: 'handleClear',
    value: function handleClear() {
      var t = this;
      t.setState({
        value: deepcopy(t.props.value)
      });
    }
  }, {
    key: 'handleOk',
    value: function handleOk() {
      var t = this;
      var _t$state = t.state;
      var startDate = _t$state.startDate;
      var endDate = _t$state.endDate;

      if (!!t.state.value.startDate) {
        t.props.onOk(t.state.value);
      }
    }
  }, {
    key: 'renderTopPanel',
    value: function renderTopPanel() {
      return React.createElement(
        'div',
        { className: classnames(_defineProperty({}, prefixClass("top-panel"), true)) },
        React.createElement(
          'span',
          { className: prefixClass("top-panel-cancel"), onClick: this.handleCanel.bind(this) },
          this.locale['button']['cancel']
        ),
        React.createElement(
          'span',
          { className: prefixClass("top-panel-title") },
          this.props.topPanelTitle || '选择时间'
        ),
        React.createElement(
          'span',
          { className: prefixClass("top-panel-confirm"), onClick: this.handleOk.bind(this) },
          this.locale['button']['confirm']
        )
      );
    }
  }, {
    key: 'render',
    value: function render() {
      var _classnames2;

      var t = this;
      var _t$props = t.props;
      var visible = _t$props.visible;
      var className = _t$props.className;
      var singleMode = _t$props.singleMode;

      var button = t.locale['button'];

      // Calculate the height of the current container
      var clientHeight = document.documentElement.clientHeight;
      var height = 230;
      !!t.props.showTopPanel && (height += 44);
      !!t.props.showHalfDay && (height += 120);

      return React.createElement(
        Layer,
        { visible: visible },
        React.createElement(
          'div',
          { className: prefixClass("calendar-container"), style: {
              height: clientHeight,
              // Scale the view to ensure user can see the whole widgit 
              // on the small screen device
              transform: height >= clientHeight ? 'scale(' + ((clientHeight / height).toFixed(3) - 0.15) + ')' : ''
            } },
          React.createElement(
            'div',
            { className: classnames((_classnames2 = {}, _defineProperty(_classnames2, prefixClass("calendar"), true), _defineProperty(_classnames2, className, !!className), _classnames2)), style: {
                display: visible ? 'block' : 'none',
                height: height
              } },
            t.renderTopPanel(),
            React.createElement(Year, { value: t.state.value, onChange: t.handleChange.bind(t), singleMode: singleMode })
          )
        )
      );
    }
  }]);

  return YearCalendar;
}(React.Component);

YearCalendar.displayName = "YearCalendar";
YearCalendar.defaultProps = {
  locale: 'zh-cn',
  onCancel: function onCancel() {},
  onOk: function onOk() {},
  value: {
    startDate: new Date().getTime(),
    startDateType: 'FULL',
    endDateType: 'FULL'
  },
  showTopPanel: true,
  singleMode: false
};
YearCalendar.propTypes = {
  value: React.PropTypes.object,
  locale: React.PropTypes.string,
  onCancel: React.PropTypes.func,
  onOk: React.PropTypes.func,
  visible: React.PropTypes.bool,
  singleMode: React.PropTypes.bool
};

module.exports = YearCalendar;
//# sourceMappingURL=data:application/json;base64,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QUE0QjtBQUMxQixVQUFRLE9BRGtCO0FBRTFCLFlBQVUsb0JBQU0sQ0FDZixDQUh5QjtBQUkxQixRQUFNLGdCQUFNLENBQ1gsQ0FMeUI7QUFNMUIsU0FBTztBQUNMLGVBQVcsSUFBSSxJQUFKLEdBQVcsT0FBWCxFQUROO0FBRUwsbUJBQWUsTUFGVjtBQUdMLGlCQUFhO0FBSFIsR0FObUI7QUFXMUIsZ0JBQWMsSUFYWTtBQVkxQixjQUFZO0FBWmMsQ0FBNUI7QUFjQSxhQUFhLFNBQWIsR0FBeUI7QUFDdkIsU0FBTyxNQUFNLFNBQU4sQ0FBZ0IsTUFEQTtBQUV2QixVQUFRLE1BQU0sU0FBTixDQUFnQixNQUZEO0FBR3ZCLFlBQVUsTUFBTSxTQUFOLENBQWdCLElBSEg7QUFJdkIsUUFBTSxNQUFNLFNBQU4sQ0FBZ0IsSUFKQztBQUt2QixXQUFTLE1BQU0sU0FBTixDQUFnQixJQUxGO0FBTXZCLGNBQVksTUFBTSxTQUFOLENBQWdCO0FBTkwsQ0FBekI7O0FBU0EsT0FBTyxPQUFQLEdBQWlCLFlBQWpCIiwiZmlsZSI6IlllYXJDYWxlbmRhci5qcyIsInNvdXJjZXNDb250ZW50IjpbImxldCBjbGFzc25hbWVzID0gcmVxdWlyZSgnY2xhc3NuYW1lcycpO1xubGV0IGRlZXBjb3B5ID0gcmVxdWlyZSgnZGVlcGNvcHknKTtcbmxldCBkZWVwRXF1YWwgPSByZXF1aXJlKCdkZWVwLWVxdWFsJyk7XG5sZXQgaTE4biA9IHJlcXVpcmUoJy4vaTE4bicpO1xuXG5sZXQgTGF5ZXIgPSByZXF1aXJlKCdAYWxpL3RpbmdsZS1sYXllcicpO1xubGV0IEZvcm1hdHRlciA9IHJlcXVpcmUoJ3V4Y29yZS1mb3JtYXR0ZXInKTtcbmxldCBZZWFyID0gcmVxdWlyZSgnLi9saWIvWWVhcicpO1xubGV0IENvbnRleHQgPSByZXF1aXJlKCdAYWxpL3RpbmdsZS1jb250ZXh0Jyk7XG5cbmxldCBwcmVmaXhDbGFzcyA9IENvbnRleHQucHJlZml4Q2xhc3M7XG5cbmNsYXNzIFllYXJDYWxlbmRhciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMudmFsdWUgPSBkZWVwY29weShwcm9wcy52YWx1ZSk7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIHZhbHVlOiBkZWVwY29weShwcm9wcy52YWx1ZSksXG4gICAgICBwYW5lbDogJ3llYXInXG4gICAgfVxuICB9XG5cbiAgY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgIGxldCB0ID0gdGhpcztcbiAgICB0LmxvY2FsZSA9IGkxOG5bdC5wcm9wcy5sb2NhbGVdO1xuICB9XG5cbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICBsZXQgdCA9IHRoaXM7XG4gICAgaWYgKCFkZWVwRXF1YWwobmV4dFByb3BzLnZhbHVlLCB0LnZhbHVlKSkge1xuICAgICAgdC52YWx1ZSA9IGRlZXBjb3B5KG5leHRQcm9wcy52YWx1ZSk7XG4gICAgICB0LnNldFN0YXRlKHtcbiAgICAgICAgdmFsdWU6IGRlZXBjb3B5KG5leHRQcm9wcy52YWx1ZSlcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgaGFuZGxlQ2hhbmdlKHZhbHVlKSB7XG4gICAgbGV0IHQgPSB0aGlzO1xuICAgIHQuc2V0U3RhdGUoe1xuICAgICAgdmFsdWU6IHZhbHVlXG4gICAgfSlcbiAgfVxuXG4gIGhhbmRsZUNhbmVsKCkge1xuICAgIGxldCB0ID0gdGhpcztcbiAgICB0LnByb3BzLm9uQ2FuY2VsKClcbiAgfVxuXG4gIGhhbmRsZUNsZWFyKCkge1xuICAgIGxldCB0ID0gdGhpcztcbiAgICB0LnNldFN0YXRlKHtcbiAgICAgIHZhbHVlOiBkZWVwY29weSh0LnByb3BzLnZhbHVlKVxuICAgIH0pXG4gIH1cblxuICBoYW5kbGVPaygpIHtcbiAgICBsZXQgdCA9IHRoaXM7XG4gICAgbGV0IHtzdGFydERhdGUsIGVuZERhdGV9ID0gdC5zdGF0ZTtcbiAgICBpZiAoISF0LnN0YXRlLnZhbHVlLnN0YXJ0RGF0ZSkge1xuICAgICAgdC5wcm9wcy5vbk9rKHQuc3RhdGUudmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHJlbmRlclRvcFBhbmVsKCkge1xuICAgIHJldHVybiA8ZGl2IGNsYXNzTmFtZT17Y2xhc3NuYW1lcyh7W3ByZWZpeENsYXNzKFwidG9wLXBhbmVsXCIpXTogdHJ1ZX0pfT5cbiAgICAgIDxzcGFuIGNsYXNzTmFtZT17cHJlZml4Q2xhc3MoXCJ0b3AtcGFuZWwtY2FuY2VsXCIpfSBvbkNsaWNrPXt0aGlzLmhhbmRsZUNhbmVsLmJpbmQodGhpcyl9Pnt0aGlzLmxvY2FsZVsnYnV0dG9uJ11bJ2NhbmNlbCddfTwvc3Bhbj5cbiAgICAgIDxzcGFuIGNsYXNzTmFtZT17cHJlZml4Q2xhc3MoXCJ0b3AtcGFuZWwtdGl0bGVcIil9Pnt0aGlzLnByb3BzLnRvcFBhbmVsVGl0bGUgfHwgJ+mAieaLqeaXtumXtCd9PC9zcGFuPlxuICAgICAgPHNwYW4gY2xhc3NOYW1lPXtwcmVmaXhDbGFzcyhcInRvcC1wYW5lbC1jb25maXJtXCIpfSBvbkNsaWNrPXt0aGlzLmhhbmRsZU9rLmJpbmQodGhpcyl9Pnt0aGlzLmxvY2FsZVsnYnV0dG9uJ11bJ2NvbmZpcm0nXX08L3NwYW4+XG4gICAgPC9kaXY+XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgbGV0IHQgPSB0aGlzO1xuICAgIGxldCB7dmlzaWJsZSwgY2xhc3NOYW1lLCBzaW5nbGVNb2RlfSA9IHQucHJvcHM7XG4gICAgbGV0IGJ1dHRvbiA9IHQubG9jYWxlWydidXR0b24nXTtcblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgaGVpZ2h0IG9mIHRoZSBjdXJyZW50IGNvbnRhaW5lclxuICAgIGxldCBjbGllbnRIZWlnaHQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0XG4gICAgbGV0IGhlaWdodCA9IDIzMFxuICAgICEhdC5wcm9wcy5zaG93VG9wUGFuZWwgJiYgKGhlaWdodCArPSA0NCk7IFxuICAgICEhdC5wcm9wcy5zaG93SGFsZkRheSAmJiAoaGVpZ2h0ICs9IDEyMCk7IFxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxMYXllciB2aXNpYmxlPXt2aXNpYmxlfT5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e3ByZWZpeENsYXNzKFwiY2FsZW5kYXItY29udGFpbmVyXCIpfSBzdHlsZT17e1xuICAgICAgICAgIGhlaWdodDogY2xpZW50SGVpZ2h0LFxuICAgICAgICAgIC8vIFNjYWxlIHRoZSB2aWV3IHRvIGVuc3VyZSB1c2VyIGNhbiBzZWUgdGhlIHdob2xlIHdpZGdpdCBcbiAgICAgICAgICAvLyBvbiB0aGUgc21hbGwgc2NyZWVuIGRldmljZVxuICAgICAgICAgIHRyYW5zZm9ybTogaGVpZ2h0ID49IGNsaWVudEhlaWdodCA/ICdzY2FsZSgnICsgKChjbGllbnRIZWlnaHQgLyBoZWlnaHQpLnRvRml4ZWQoMykgLSAwLjE1ICkrICcpJyA6ICcnXG4gICAgICAgIH19PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y2xhc3NuYW1lcyh7XG4gICAgICAgICAgICAgICAgICAgIFtwcmVmaXhDbGFzcyhcImNhbGVuZGFyXCIpXTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgW2NsYXNzTmFtZV06ICEhY2xhc3NOYW1lXG4gICAgICAgICAgICAgICAgfSl9IHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IHZpc2libGUgPyAnYmxvY2snIDogJ25vbmUnLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgICAgICAgICAgIH19PlxuICAgICAgICAgIHt0LnJlbmRlclRvcFBhbmVsKCl9XG4gICAgICAgICAgPFllYXIgdmFsdWU9e3Quc3RhdGUudmFsdWV9IG9uQ2hhbmdlPXt0LmhhbmRsZUNoYW5nZS5iaW5kKHQpfSBzaW5nbGVNb2RlPXtzaW5nbGVNb2RlfS8+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvTGF5ZXI+XG4gICAgKVxuICB9XG59XG5cblllYXJDYWxlbmRhci5kaXNwbGF5TmFtZSA9IFwiWWVhckNhbGVuZGFyXCI7XG5ZZWFyQ2FsZW5kYXIuZGVmYXVsdFByb3BzID0ge1xuICBsb2NhbGU6ICd6aC1jbicsXG4gIG9uQ2FuY2VsOiAoKSA9PiB7XG4gIH0sXG4gIG9uT2s6ICgpID0+IHtcbiAgfSxcbiAgdmFsdWU6IHtcbiAgICBzdGFydERhdGU6IG5ldyBEYXRlKCkuZ2V0VGltZSgpLFxuICAgIHN0YXJ0RGF0ZVR5cGU6ICdGVUxMJyxcbiAgICBlbmREYXRlVHlwZTogJ0ZVTEwnXG4gIH0sXG4gIHNob3dUb3BQYW5lbDogdHJ1ZSxcbiAgc2luZ2xlTW9kZTogZmFsc2Vcbn07XG5ZZWFyQ2FsZW5kYXIucHJvcFR5cGVzID0ge1xuICB2YWx1ZTogUmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgbG9jYWxlOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICBvbkNhbmNlbDogUmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gIG9uT2s6IFJlYWN0LlByb3BUeXBlcy5mdW5jLFxuICB2aXNpYmxlOiBSZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgc2luZ2xlTW9kZTogUmVhY3QuUHJvcFR5cGVzLmJvb2xcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gWWVhckNhbGVuZGFyO1xuIl0sInNvdXJjZVJvb3QiOiIvc291cmNlLyJ9
