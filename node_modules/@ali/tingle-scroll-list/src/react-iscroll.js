'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var React = require('react');
var ReactDOM = require('react-dom');
var equal = require('deep-equal');
var PropTypes = React.PropTypes;

// Events available on iScroll instance
// [`iScroll event name`, `react component event name`]

var availableEvents = [['beforeScrollStart', "onBeforeScrollStart"], ['scrollCancel', "onScrollCancel"], ['scrollStart', "onScrollStart"], ['scroll', "onScroll"], ['scrollEnd', "onScrollEnd"], ['flick', "onFlick"], ['zoomStart', "onZoomStart"], ['zoomEnd', "onZoomEnd"]];

var iScrollPropType = function iScrollPropType(props, propName, componentName) {
  var iScroll = props[propName];
  var proto = iScroll && iScroll.prototype;

  if (!iScroll || !proto || !proto.version || !proto.scrollTo) {
    return new Error(componentName + ": iScroll not passed to component props.");
  } else {
    if (!/^5\..*/.test(proto.version)) {
      console.warn(componentName + ": different version than 5.x.y of iScroll is required. Some features won't work properly.");
    }

    if (props.options && props.options.zoom && !proto.zoom) {
      console.warn(componentName + ": options.zoom is set, but iscroll-zoom version is not required. Zoom feature won't work properly.");
    }
  }
};

// Generate propTypes with event function validating
var propTypes = {
  defer: React.PropTypes.oneOfType([React.PropTypes.bool, React.PropTypes.number]),
  options: PropTypes.object,
  iScroll: iScrollPropType,
  onRefresh: PropTypes.func
};

for (var i = 0; i < availableEvents.length; i++) {
  propTypes[availableEvents[i][1]] = PropTypes.func;
}

var ReactIScroll = function (_React$Component) {
  _inherits(ReactIScroll, _React$Component);

  function ReactIScroll(props) {
    _classCallCheck(this, ReactIScroll);

    var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

    _this._queuedCallbacks = [];
    _this._iScrollBindedEvents = {};
    return _this;
  }

  ReactIScroll.prototype.componentDidMount = function componentDidMount() {
    this._initializeIScroll();
  };

  ReactIScroll.prototype.componentWillUnmount = function componentWillUnmount() {
    this._teardownIScroll();
  };

  // There is no state, we can compare only props.


  ReactIScroll.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
    return !equal(this.props, nextProps);
  };

  // Check if iScroll options has changed and recreate instance with new one


  ReactIScroll.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {
    var _this2 = this;

    // If options are same, iScroll behaviour will not change. Just refresh events and trigger refresh
    if (equal(prevProps.options, this.props.options)) {
      this._updateIScrollEvents(prevProps, this.props);
      this.refresh();

      // If options changed, we will destroy iScroll instance and create new one with same scroll position
      // TODO test if this will work with indicators
    } else {
      this.withIScroll(true, function (iScrollInstance) {
        // Save current state
        var x = iScrollInstance.x;
        var y = iScrollInstance.y;
        var scale = iScrollInstance.scale;

        // Destroy current and Create new instance of iScroll

        _this2._teardownIScroll();
        _this2._initializeIScroll();

        _this2.withIScroll(true, function (newIScrollInstance) {
          // Restore previous state
          if (scale && newIScrollInstance.zoom) newIScrollInstance.zoom(scale, 0, 0, 0);

          newIScrollInstance.scrollTo(x, y);
        });
      });
    }
  };

  ReactIScroll.prototype.getIScroll = function getIScroll() {
    return this._iScrollInstance;
  };

  ReactIScroll.prototype.getIScrollInstance = function getIScrollInstance() {
    console.warn("Function 'getIScrollInstance' is deprecated. Instead use 'getIScroll'");
    return this._iScrollInstance;
  };

  ReactIScroll.prototype.withIScroll = function withIScroll(waitForInit, callback) {
    if (!callback && typeof waitForInit == "function") {
      callback = waitForInit;
    }

    if (this.getIScroll()) {
      callback(this.getIScroll());
    } else if (waitForInit === true) {
      this._queuedCallbacks.push(callback);
    }
  };

  ReactIScroll.prototype.refresh = function refresh() {
    this.withIScroll(function (iScrollInstance) {
      return iScrollInstance.refresh();
    });
  };

  ReactIScroll.prototype._runInitializeIScroll = function _runInitializeIScroll() {
    var _this3 = this;

    var _props = this.props;
    var iScroll = _props.iScroll;
    var options = _props.options;

    // Create iScroll instance with given options

    var iScrollInstance = new iScroll(ReactDOM.findDOMNode(this), options);
    this._iScrollInstance = iScrollInstance;

    // TODO there should be new event 'onInitialize'
    // this._triggerRefreshEvent()

    // Patch iScroll instance .refresh() function to trigger our onRefresh event
    var origRefresh = iScrollInstance.refresh;

    iScrollInstance.refresh = function () {
      origRefresh.apply(iScrollInstance);
      _this3._triggerRefreshEvent();
    };

    // Bind iScroll events
    this._bindIScrollEvents();

    this._callQueuedCallbacks();
  };

  ReactIScroll.prototype._initializeIScroll = function _initializeIScroll() {
    var _this4 = this;

    var defer = this.props.defer;


    if (!defer) {
      this._runInitializeIScroll();
    } else {
      setTimeout(function () {
        return _this4._runInitializeIScroll();
      }, defer);
    }
  };

  ReactIScroll.prototype._callQueuedCallbacks = function _callQueuedCallbacks() {
    var callbacks = this._queuedCallbacks,
        len = callbacks.length;

    this._queuedCallbacks = [];

    for (var _i = 0; _i < len; _i++) {
      callbacks[_i](this.getIScroll());
    }
  };

  ReactIScroll.prototype._teardownIScroll = function _teardownIScroll() {
    if (this._iScrollInstance) {
      this._iScrollInstance.destroy();
      this._iScrollInstance = undefined;
    }
  };

  ReactIScroll.prototype._bindIScrollEvents = function _bindIScrollEvents() {
    // Bind events on iScroll instance
    this._iScrollBindedEvents = {};
    this._updateIScrollEvents({}, this.props);
  };

  // Iterate through available events and update one by one


  ReactIScroll.prototype._updateIScrollEvents = function _updateIScrollEvents(prevProps, nextProps) {
    var len = availableEvents.length;

    for (var _i2 = 0; _i2 < len; _i2++) {
      var _availableEvents$_i = _slicedToArray(availableEvents[_i2], 2);

      var iScrollEventName = _availableEvents$_i[0];
      var reactEventName = _availableEvents$_i[1];

      this._updateIScrollEvent(iScrollEventName, prevProps[reactEventName], nextProps[reactEventName]);
    }
  };

  // Unbind and/or Bind event if it was changed during update


  ReactIScroll.prototype._updateIScrollEvent = function _updateIScrollEvent(iScrollEventName, prevEvent, currentEvent) {
    var _this5 = this;

    if (prevEvent !== currentEvent) {
      this.withIScroll(true, function (iScrollInstance) {
        var currentEvents = _this5._iScrollBindedEvents;

        if (prevEvent) {
          iScrollInstance.off(iScrollEventName, currentEvents[iScrollEventName]);
          currentEvents[iScrollEventName] = undefined;
        }

        if (currentEvent) {
          var wrappedCallback = function wrappedCallback() {
            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }

            currentEvent.apply(undefined, [iScrollInstance].concat(args));
          };

          iScrollInstance.on(iScrollEventName, wrappedCallback);
          currentEvents[iScrollEventName] = wrappedCallback;
        }
      });
    }
  };

  ReactIScroll.prototype._triggerRefreshEvent = function _triggerRefreshEvent() {
    var onRefresh = this.props.onRefresh;


    if (onRefresh) {
      this.withIScroll(function (iScrollInstance) {
        return onRefresh(iScrollInstance);
      });
    }
  };

  ReactIScroll.prototype.render = function render() {
    // Keep only html properties
    var htmlProps = {};

    for (var prop in this.props) {
      if (!propTypes[prop] && prop !== "children") {
        htmlProps[prop] = this.props[prop];
      }
    }

    return React.createElement(
      'div',
      _extends({ key: 'iscroll' }, htmlProps),
      this.props.children
    );
  };

  return ReactIScroll;
}(React.Component);

ReactIScroll.displayName = 'ReactIScroll';
ReactIScroll.propTypes = propTypes;
ReactIScroll.defaultProps = {
  defer: 0,
  options: {},
  style: {
    flex:1,
    position: "relative",
    height: "100%",
    width: "100%",
    overflow: "hidden"
  },
  bounceEasing: 'elastic',
  bounceTime: 100
};
exports.default = ReactIScroll;
module.exports = exports['default'];
