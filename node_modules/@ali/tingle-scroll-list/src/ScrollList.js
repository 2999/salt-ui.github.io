/**
 * ScrollList Component for tingle
 * @author zhouquan.yezq
 *
 * Copyright 2014-2016, Tingle Team.
 * All rights reserved.
 */

const classnames = require('classnames');
const Context = require('@ali/tingle-context');
const ReactIScroll = require('./react-iscroll');
const iScroll = require('iscroll');
const {PropTypes} = React;
const DataSourceParser = require('@ali/vu-data-source-parser');
const equal = require('deep-equal');
const assign = require("object-assign");
const _ = require("lodash");
import PushLoader from './PushLoader';
import PullLoader from './PullLoader';

const LS = window.localStorage || {};
const LS_CACHE_KEY = 'SCROLL_LIST_CACHE_KEY_';

class ScrollList extends React.Component {

    constructor(props) {
        super(props);

        // 用于缓存的 ID
        this.cacheId = props.cacheId;
        this.needFirstScreenCache = props.needFirstScreenCache;
        this.page = props.page || 0;
        this.pageSize = props.pageSize || 10;
        this.params = props.params;
        this.lastPage = this.page;
        this.state = {
            data: [],
            pushLoaderDataGetted: false, // 已经加载过数据
            pushLoaderStatus: 'default',
            pullLoaderStatus: 'default',
            scrollInnerMinHeight: '101%',
            cachedChildren: {},
            showTip: true,
        };

        this.noData = false;
    }

    gFunction(fbody) {
        let eventHandler = fbody;
        let code = `
            var __cb = ${eventHandler};
            if (typeof __cb === 'function') {
                return __cb(d);
            }
            __cb = null;
            `;
        return (new Function('d', code));
    }

    clearCache() {
        this.state.cachedChildren = {};
    }

    componentDidMount() {
        let {dataSource} = this.props;
        this.parser = DataSourceParser(dataSource, {
            willFetch: (vars, config) => {
                let _d = vars.data;

                var page = this.page;
                var pageSize = this.pageSize;

                //参数中添加this.params中的内容,从props.params中同步
                assign(_d, this.params || {});

                _d.currentPage = page;//遵守之前的标准
                _d.pageSize = pageSize;//遵守之前的标准

                if (typeof dataSource.willFetch == 'string') {
                    dataSource.willFetch = this.gFunction(dataSource.willFetch)
                }
                vars.data = dataSource.willFetch(_d || {});
            }
        });
        if(!this.props.scrollLoad) {
            this.refs.iscroll.withIScroll(iscroll => {
                iscroll.disable();
            });
        }

        this.refs.iscroll.withIScroll(instance => {
            this.refs.pullLoader.acceptIScrollInstance(instance);
            this.refs.pushLoader.acceptIScrollInstance(instance);
        });

        const offsetHeight = this.refs.root.offsetHeight;
        this.setState({
            scrollInnerMinHeight: (offsetHeight ? offsetHeight : this.props.listHeight)  + 54 
        })
    }

    componentWillReceiveProps(nextProps) {
        if (!equal(this.props.params, nextProps.params)) {
            this.params = nextProps.params;
            //this.page = nextProps.params.currentPage || this.page;
            this.pageSize = nextProps.params.pageSize || this.pageSize;
            this.onReload();
        }
    }

    fetchData() {
        const me = this;
        return new Promise(function(resolve, reject) {
            if(!me.parser) {
                reject();
                return false;
            }

            me.parser(me.props).then(function (content) {
                if(me.isNoData(content)) {
                    me.noData = true;
                }

                resolve(content);
            }, reject);
        });
    }

    isNoData(content) {
        return !_.isArray(content) || _.isEmpty(content);
    }

    // iterate the data & render the child attach with props
    // note the repeat just accept the one root child
    renderChild() {
        try {
            let props = this.props, child = props.children, rchild, oChild,
                _data = this.state.data;

            if (!props.children || props.children.length < 1) {
                return null;
            }

            rchild = child.length ? child.slice(-1)[0] : child;

            if (_data && _data instanceof Array) {
                return <div className="">
                    {this.renderOtherChild(oChild)}
                    {this.repeatChild(_data, rchild)}
                </div>;
            }
        } catch (e) {
            console.info(e);
        }
    }

    // ScrollList会接受多个child,但只会对最后一个child使用iscroll渲染,其它child正常渲染
    renderOtherChild() {
        let child = this.props.children;
        if (child.length) {
            child = child.slice(0, child.length - 1)
        } else {
            child = [];
        }
        return child.map((item, index) => {
            return React.cloneElement(item, {
                key: index,
                index: index
            })
        })
    }

    repeatChild(_data, child) {
        const cache = this.props.cache;
        let cached = this.state.cachedChildren;

        return _data.map(cache ? (item, index) => {
            if (!cached[index]) {
                cached[index] = React.cloneElement(child, {
                    key: index,
                    index: index,
                    first: index == 0,
                    last: index == _data.length - 1,
                    odd: (index + 1) % 2 !== 0,
                    data: item,
                    ...item
                })
            }
            return cached[index];
        } : (item, index) => {
            return React.cloneElement(child, {
                key: index,
                index: index,
                first: index == 0,
                last: index == _data.length - 1,
                odd: (index + 1) % 2 !== 0,
                data: item,
                ...item
            })
        })
    }

    onScrollRefresh() {
        this.refs.pullLoader.resetPositionIfNeeded();
    }

    render() {
        let iScrollOptions = this.props.options;

        return (
            <div ref="root" className={classnames(Context.prefixClass('scroll-list'), {
                [this.props.className]: !!this.props.className
            })}>
                <ReactIScroll
                    key="iscroll"
                    ref="iscroll"
                    iScroll={iScroll}
                    options={iScrollOptions}
                    onRefresh={this.onScrollRefresh.bind(this)}
                >
                    <div
                        ref="inner"
                        className={Context.prefixClass('scroll-list-inner')}
                        style={{'minHeight': this.state.scrollInnerMinHeight}}
                    >
                        <PullLoader
                            ref="pullLoader"
                            {...this.props}
                            status={this.state.pullLoaderStatus}
                            onPullLoad={this.onReload.bind(this)}
                        />
                        {
                            this.renderChild()
                        }
                        <PushLoader ref="pushLoader"
                            {...this.props}
                            dataGetted={this.state.pushLoaderDataGetted}
                            allData={this.state.data}
                            status={this.state.pushLoaderStatus}
                            pullStatus={this.state.pullLoaderStatus}
                            showTip={this.state.showTip}
                            onLoadMore={this.loadMore.bind(this)} />
                    </div>
                </ReactIScroll>
            </div>
        );
    }

    // 在顶部下拉重新加载数据
    onReload(loaded) {
        this.noData = false;
        this.lastPage = this.page;
        this.page = 1;

        this.setState({
            pushLoaderStatus: 'loading',
            pullLoaderStatus: this.state.pushLoaderDataGetted ? 'loading' : 'default',
        });

        this.fetchData().then(data => {
            loaded && loaded();
            
            this.clearCache();
            this.setState({
                pullLoaderStatus: '',
                data: data || [],
                pushLoaderDataGetted: true,
                showTip: true,
                pushLoaderStatus: data.length ? 'default' : 'nodata',
            }, () => {
                const showTip = this.state.scrollInnerMinHeight < this.refs.inner.offsetHeight - 54;
                if (showTip) {
                    this.refs.pushLoader.maybeVisible();
                } else {
                    this.setState({
                        showTip: false
                    })
                }
            });

            
        }, err => {
            this.page = this.lastPage;
            this.setState({
                pullLoaderStatus: '',
            });

            console.log(err);
        });
    }

    // 在底部上拉加载下一屏数据
    loadMore(loaded) {
        //加载下一页数据
        if (this.noData) {
            return false;
        }

        const isFirstPage = this.page === 0;
        this.lastPage = this.page;
        this.page = this.page + 1;

        this.setState({
            pushLoaderStatus: 'loading'
        });

        if (isFirstPage && this.needFirstScreenCache){
            try {
                const cachedData = JSON.parse(LS.getItem(`${LS_CACHE_KEY}${this.cacheId}`));
                if (cachedData && cachedData.length){
                    this.setState({
                        data: cachedData,
                        pushLoaderStatus: 'default',
                        pushLoaderDataGetted: true
                    }, () => {
                        // should clear children cache to avoid bug.
                        this.clearCache()
                    });
                }
            } catch(e){
                console.error(e.stack);
            }
        }

        this.fetchData().then(data => {
            loaded && loaded(!data.length);
            this.setState({
                data: isFirstPage && this.needFirstScreenCache ? data : _.concat([], this.state.data, data),
                pushLoaderStatus: !data.length ? 'nodata' : 'default',
                pushLoaderDataGetted: true,
                showTip: this.state.scrollInnerMinHeight < this.refs.inner.offsetHeight - 54
            });
            try {
                if (isFirstPage && this.needFirstScreenCache) {
                    LS.setItem(`${LS_CACHE_KEY}${this.cacheId}`, JSON.stringify(data))
                }
            }catch(e){
                console.error(e.stack);
            }
        }, err => {
            this.page = this.lastPage;
            this.setState({
                pushLoaderStatus: 'error',
            });
            console.log(err);
        });
    }
}

ScrollList.defaultProps = {
    className: '',
    params: {},
    options: {
        //iscroll 默认屏蔽内部的 click 事件，先简单使用这种方式解决 chrome 和 Android 无法点击的问题
        //后面要使用这种方式改进 `addEventListener('iscroll:tap', function(e) {})`
        click: /chrome/i.test(navigator.userAgent),
        scrollbars: false,
        // y: -24
        probeType: 3,
    },
    scrollLoad: true, // 是否支持滚动,来自设计器配置
    pageSize: 10,
    //beforeFetch: x => {},
    loadingTip: '加载中...',
    noDataTip: '暂无数据',
    noDataImage: 'https://img.alicdn.com/tps/TB1K6mHNpXXXXXiXpXXXXXXXXXX-1000-1000.svg',
    noMoreDataTip: '没有更多了',
    pullLoadTip: '下拉显示更多',
    pushLoadTip: '上拉显示更多',
    errorTip: '获取数据失败',
    cache: true,
    needFirstScreenCache: false,
};

// http://facebook.github.io/react/docs/reusable-components.html
ScrollList.propTypes = {
    className: PropTypes.string,
    scrollLoad: PropTypes.bool,
    //beforeFetch: PropTypes.func,
    loadingTip: PropTypes.string,
    noDataTip: PropTypes.string,
    noDataImage: PropTypes.string,
    noMoreDataTip: PropTypes.string,
    pullLoadTip: PropTypes.string,
    pushLoadTip: PropTypes.string,
    errorTip: PropTypes.string,
    pageSize: PropTypes.number,
    params: PropTypes.object,
    needFirstScreenCache: PropTypes.bool,
    cacheId: PropTypes.oneOfType([
        PropTypes.number,
        PropTypes.string
    ]),
    options: PropTypes.object,
    cache: PropTypes.bool,
};

ScrollList.displayName = 'ScrollList';

module.exports = ScrollList;
