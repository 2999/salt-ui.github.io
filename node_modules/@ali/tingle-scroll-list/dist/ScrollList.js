'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _PushLoader = require('./PushLoader');

var _PushLoader2 = _interopRequireDefault(_PushLoader);

var _PullLoader = require('./PullLoader');

var _PullLoader2 = _interopRequireDefault(_PullLoader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * ScrollList Component for tingle
 * @author zhouquan.yezq
 *
 * Copyright 2014-2016, Tingle Team.
 * All rights reserved.
 */

var classnames = require('classnames');
var Context = require('@ali/tingle-context');
var ReactIScroll = require('./react-iscroll');
var iScroll = require('iscroll');
var _React = React;
var PropTypes = _React.PropTypes;

var DataSourceParser = require('@ali/vu-data-source-parser');
var equal = require('deep-equal');
var assign = require("object-assign");
var _ = require("lodash");


var LS = window.localStorage || {};
var LS_CACHE_KEY = 'SCROLL_LIST_CACHE_KEY_';

var ScrollList = function (_React$Component) {
    _inherits(ScrollList, _React$Component);

    function ScrollList(props) {
        _classCallCheck(this, ScrollList);

        // 用于缓存的 ID
        var _this = _possibleConstructorReturn(this, (ScrollList.__proto__ || Object.getPrototypeOf(ScrollList)).call(this, props));

        _this.cacheId = props.cacheId;
        _this.needFirstScreenCache = props.needFirstScreenCache;
        _this.page = props.page || 0;
        _this.pageSize = props.pageSize || 10;
        _this.params = props.params;
        _this.lastPage = _this.page;
        _this.state = {
            data: [],
            pushLoaderDataGetted: false, // 已经加载过数据
            pushLoaderStatus: 'default',
            pullLoaderStatus: 'default',
            scrollInnerMinHeight: '101%',
            cachedChildren: {},
            showTip: true
        };

        _this.noData = false;
        return _this;
    }

    _createClass(ScrollList, [{
        key: 'gFunction',
        value: function gFunction(fbody) {
            var eventHandler = fbody;
            var code = '\n            var __cb = ' + eventHandler + ';\n            if (typeof __cb === \'function\') {\n                return __cb(d);\n            }\n            __cb = null;\n            ';
            return new Function('d', code);
        }
    }, {
        key: 'clearCache',
        value: function clearCache() {
            this.state.cachedChildren = {};
        }
    }, {
        key: 'componentDidMount',
        value: function componentDidMount() {
            var _this2 = this;

            var dataSource = this.props.dataSource;

            this.parser = DataSourceParser(dataSource, {
                willFetch: function willFetch(vars, config) {
                    var _d = vars.data;

                    var page = _this2.page;
                    var pageSize = _this2.pageSize;

                    //参数中添加this.params中的内容,从props.params中同步
                    assign(_d, _this2.params || {});

                    _d.currentPage = page; //遵守之前的标准
                    _d.pageSize = pageSize; //遵守之前的标准

                    if (typeof dataSource.willFetch == 'string') {
                        dataSource.willFetch = _this2.gFunction(dataSource.willFetch);
                    }
                    vars.data = dataSource.willFetch(_d || {});
                }
            });
            if (!this.props.scrollLoad) {
                this.refs.iscroll.withIScroll(function (iscroll) {
                    iscroll.disable();
                });
            }

            this.refs.iscroll.withIScroll(function (instance) {
                _this2.refs.pullLoader.acceptIScrollInstance(instance);
                _this2.refs.pushLoader.acceptIScrollInstance(instance);
            });

            var offsetHeight = this.refs.root.offsetHeight;
            this.setState({
                scrollInnerMinHeight: (offsetHeight ? offsetHeight : this.props.listHeight) + 54
            });
        }
    }, {
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            if (!equal(this.props.params, nextProps.params)) {
                this.params = nextProps.params;
                //this.page = nextProps.params.currentPage || this.page;
                this.pageSize = nextProps.params.pageSize || this.pageSize;
                this.onReload();
            }
        }
    }, {
        key: 'fetchData',
        value: function fetchData() {
            var me = this;
            return new Promise(function (resolve, reject) {
                if (!me.parser) {
                    reject();
                    return false;
                }

                me.parser(me.props).then(function (content) {
                    if (me.isNoData(content)) {
                        me.noData = true;
                    }

                    resolve(content);
                }, reject);
            });
        }
    }, {
        key: 'isNoData',
        value: function isNoData(content) {
            return !_.isArray(content) || _.isEmpty(content);
        }

        // iterate the data & render the child attach with props
        // note the repeat just accept the one root child

    }, {
        key: 'renderChild',
        value: function renderChild() {
            try {
                var props = this.props,
                    child = props.children,
                    rchild = void 0,
                    oChild = void 0,
                    _data = this.state.data;

                if (!props.children || props.children.length < 1) {
                    return null;
                }

                rchild = child.length ? child.slice(-1)[0] : child;

                if (_data && _data instanceof Array) {
                    return React.createElement(
                        'div',
                        { className: '' },
                        this.renderOtherChild(oChild),
                        this.repeatChild(_data, rchild)
                    );
                }
            } catch (e) {
                console.info(e);
            }
        }

        // ScrollList会接受多个child,但只会对最后一个child使用iscroll渲染,其它child正常渲染

    }, {
        key: 'renderOtherChild',
        value: function renderOtherChild() {
            var child = this.props.children;
            if (child.length) {
                child = child.slice(0, child.length - 1);
            } else {
                child = [];
            }
            return child.map(function (item, index) {
                return React.cloneElement(item, {
                    key: index,
                    index: index
                });
            });
        }
    }, {
        key: 'repeatChild',
        value: function repeatChild(_data, child) {
            var cache = this.props.cache;
            var cached = this.state.cachedChildren;

            return _data.map(cache ? function (item, index) {
                if (!cached[index]) {
                    cached[index] = React.cloneElement(child, _extends({
                        key: index,
                        index: index,
                        first: index == 0,
                        last: index == _data.length - 1,
                        odd: (index + 1) % 2 !== 0,
                        data: item
                    }, item));
                }
                return cached[index];
            } : function (item, index) {
                return React.cloneElement(child, _extends({
                    key: index,
                    index: index,
                    first: index == 0,
                    last: index == _data.length - 1,
                    odd: (index + 1) % 2 !== 0,
                    data: item
                }, item));
            });
        }
    }, {
        key: 'onScrollRefresh',
        value: function onScrollRefresh() {
            this.refs.pullLoader.resetPositionIfNeeded();
        }
    }, {
        key: 'render',
        value: function render() {
            var iScrollOptions = this.props.options;

            return React.createElement(
                'div',
                { ref: 'root', className: classnames(Context.prefixClass('scroll-list'), _defineProperty({}, this.props.className, !!this.props.className)) },
                React.createElement(
                    ReactIScroll,
                    {
                        key: 'iscroll',
                        ref: 'iscroll',
                        iScroll: iScroll,
                        options: iScrollOptions,
                        onRefresh: this.onScrollRefresh.bind(this)
                    },
                    React.createElement(
                        'div',
                        {
                            ref: 'inner',
                            className: Context.prefixClass('scroll-list-inner'),
                            style: { 'minHeight': this.state.scrollInnerMinHeight }
                        },
                        React.createElement(_PullLoader2.default, _extends({
                            ref: 'pullLoader'
                        }, this.props, {
                            status: this.state.pullLoaderStatus,
                            onPullLoad: this.onReload.bind(this)
                        })),
                        this.renderChild(),
                        React.createElement(_PushLoader2.default, _extends({ ref: 'pushLoader'
                        }, this.props, {
                            dataGetted: this.state.pushLoaderDataGetted,
                            allData: this.state.data,
                            status: this.state.pushLoaderStatus,
                            pullStatus: this.state.pullLoaderStatus,
                            showTip: this.state.showTip,
                            onLoadMore: this.loadMore.bind(this) }))
                    )
                )
            );
        }

        // 在顶部下拉重新加载数据

    }, {
        key: 'onReload',
        value: function onReload(loaded) {
            var _this3 = this;

            this.noData = false;
            this.lastPage = this.page;
            this.page = 1;

            this.setState({
                pushLoaderStatus: 'loading',
                pullLoaderStatus: this.state.pushLoaderDataGetted ? 'loading' : 'default'
            });

            this.fetchData().then(function (data) {
                loaded && loaded();

                _this3.clearCache();
                _this3.setState({
                    pullLoaderStatus: '',
                    data: data || [],
                    pushLoaderDataGetted: true,
                    showTip: true,
                    pushLoaderStatus: data.length ? 'default' : 'nodata'
                }, function () {
                    var showTip = _this3.state.scrollInnerMinHeight < _this3.refs.inner.offsetHeight - 54;
                    if (showTip) {
                        _this3.refs.pushLoader.maybeVisible();
                    } else {
                        _this3.setState({
                            showTip: false
                        });
                    }
                });
            }, function (err) {
                _this3.page = _this3.lastPage;
                _this3.setState({
                    pullLoaderStatus: ''
                });

                console.log(err);
            });
        }

        // 在底部上拉加载下一屏数据

    }, {
        key: 'loadMore',
        value: function loadMore(loaded) {
            var _this4 = this;

            //加载下一页数据
            if (this.noData) {
                return false;
            }

            var isFirstPage = this.page === 0;
            this.lastPage = this.page;
            this.page = this.page + 1;

            this.setState({
                pushLoaderStatus: 'loading'
            });

            if (isFirstPage && this.needFirstScreenCache) {
                try {
                    var cachedData = JSON.parse(LS.getItem('' + LS_CACHE_KEY + this.cacheId));
                    if (cachedData && cachedData.length) {
                        this.setState({
                            data: cachedData,
                            pushLoaderStatus: 'default',
                            pushLoaderDataGetted: true
                        }, function () {
                            // should clear children cache to avoid bug.
                            _this4.clearCache();
                        });
                    }
                } catch (e) {
                    console.error(e.stack);
                }
            }

            this.fetchData().then(function (data) {
                loaded && loaded(!data.length);
                _this4.setState({
                    data: isFirstPage && _this4.needFirstScreenCache ? data : _.concat([], _this4.state.data, data),
                    pushLoaderStatus: !data.length ? 'nodata' : 'default',
                    pushLoaderDataGetted: true,
                    showTip: _this4.state.scrollInnerMinHeight < _this4.refs.inner.offsetHeight - 54
                });
                try {
                    if (isFirstPage && _this4.needFirstScreenCache) {
                        LS.setItem('' + LS_CACHE_KEY + _this4.cacheId, JSON.stringify(data));
                    }
                } catch (e) {
                    console.error(e.stack);
                }
            }, function (err) {
                _this4.page = _this4.lastPage;
                _this4.setState({
                    pushLoaderStatus: 'error'
                });
                console.log(err);
            });
        }
    }]);

    return ScrollList;
}(React.Component);

ScrollList.defaultProps = {
    className: '',
    params: {},
    options: {
        //iscroll 默认屏蔽内部的 click 事件，先简单使用这种方式解决 chrome 和 Android 无法点击的问题
        //后面要使用这种方式改进 `addEventListener('iscroll:tap', function(e) {})`
        click: /chrome/i.test(navigator.userAgent),
        scrollbars: false,
        // y: -24
        probeType: 3
    },
    scrollLoad: true, // 是否支持滚动,来自设计器配置
    pageSize: 10,
    //beforeFetch: x => {},
    loadingTip: '加载中...',
    noDataTip: '暂无数据',
    noDataImage: 'https://img.alicdn.com/tps/TB1K6mHNpXXXXXiXpXXXXXXXXXX-1000-1000.svg',
    noMoreDataTip: '没有更多了',
    pullLoadTip: '下拉显示更多',
    pushLoadTip: '上拉显示更多',
    errorTip: '获取数据失败',
    cache: true,
    needFirstScreenCache: false
};

// http://facebook.github.io/react/docs/reusable-components.html
ScrollList.propTypes = {
    className: PropTypes.string,
    scrollLoad: PropTypes.bool,
    //beforeFetch: PropTypes.func,
    loadingTip: PropTypes.string,
    noDataTip: PropTypes.string,
    noDataImage: PropTypes.string,
    noMoreDataTip: PropTypes.string,
    pullLoadTip: PropTypes.string,
    pushLoadTip: PropTypes.string,
    errorTip: PropTypes.string,
    pageSize: PropTypes.number,
    params: PropTypes.object,
    needFirstScreenCache: PropTypes.bool,
    cacheId: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
    options: PropTypes.object,
    cache: PropTypes.bool
};

ScrollList.displayName = 'ScrollList';

module.exports = ScrollList;