'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Scroller Component for tingle
 * @author gbk
 *
 * Copyright 2014-2016, Tingle Team.
 * All rights reserved.
 */
var React = require('react');
var classnames = require('classnames');
var IScroll = require('./iscroll');
var Context = require('@ali/tingle-context');

var Scroller = function (_React$Component) {
    _inherits(Scroller, _React$Component);

    function Scroller(props) {
        _classCallCheck(this, Scroller);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(Scroller).call(this, props));
    }

    _createClass(Scroller, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            var t = this;

            // 根节点的dom引用
            t.el = ReactDOM.findDOMNode(t.refs.root);

            // 初始化 iscroll
            t.initScroll();
        }
    }, {
        key: 'componentDidUnMount',
        value: function componentDidUnMount() {

            // 销毁 iscroll
            this.scroller.destroy();
        }
    }, {
        key: 'componentDidUpdate',
        value: function componentDidUpdate() {
            var t = this;

            // 避免很频繁的调用
            clearTimeout(t._timeout);
            t._timeout = setTimeout(function () {

                // 有些场景下不需要刷新
                if (t.props.autoRefresh) {

                    // 更新 iscroll
                    t.scroller && t.scroller.refresh();
                }
            }, 10);
        }
    }, {
        key: 'render',
        value: function render() {
            var t = this;

            // iscroll 需要一个 wrapper，所以里面多加了一层 div
            return React.createElement(
                'div',
                { className: classnames(Context.prefixClass('scroller'), _defineProperty({}, t.props.className, !!t.props.className)), ref: 'root' },
                React.createElement(
                    'div',
                    { className: Context.prefixClass('DIB'),
                        style: { minWidth: t.props.minWidth } },
                    this.props.children
                )
            );
        }
    }, {
        key: 'initScroll',
        value: function initScroll() {
            var t = this;

            // 参数过滤，onXxx 是事件，否则是配置参数
            var options = {};
            var events = {};
            for (var key in t.props) {
                var matches = /^on([A-Z]\w*)$/.exec(key);
                if (matches) {
                    // 事件
                    var evtName = matches[1].replace(/./, function (p) {
                        return p.toLowerCase();
                    });
                    events[evtName] = t.props[key];
                } else if (key !== 'className' && key !== 'autoRefresh' && key !== 'minWidth') {
                    // 配置
                    options[key] = t.props[key];
                }
            }

            // iscroll 实例化
            t.scroller = new IScroll(t.el, options);

            // 事件挂载
            for (var _key in events) {
                t.scroller.on(_key, events[_key].bind(null, t.scroller));
            }
        }
    }]);

    return Scroller;
}(React.Component);

// 更多配置参数，详见 http://iscrolljs.com/ ，事件用 onXxx 的格式，例如 scrollEnd 事件对应的参数是 onScrollEnd


Scroller.defaultProps = {
    click: /chrome/i.test(navigator.userAgent), //iscroll 默认屏蔽内部的 click 事件，考虑到在 chrome 中调试没开模拟器的场景，允许响应 click 点击。 http://iscrolljs.com/#basic-features
    autoRefresh: true,
    minWidth: '100%'
};

// http://facebook.github.io/react/docs/reusable-components.html
Scroller.propTypes = {
    autoRefresh: React.PropTypes.bool,
    className: React.PropTypes.string
};

module.exports = Scroller;
//# sourceMappingURL=data:application/json;base64,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QkFBYSxNQUFNLFNBQU4sQ0FBZ0IsSUFEWjtBQUVqQixlQUFXLE1BQU0sU0FBTixDQUFnQjtBQUZWLENBQXJCOztBQUtBLE9BQU8sT0FBUCxHQUFpQixRQUFqQiIsImZpbGUiOiJTY3JvbGxlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogU2Nyb2xsZXIgQ29tcG9uZW50IGZvciB0aW5nbGVcbiAqIEBhdXRob3IgZ2JrXG4gKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNiwgVGluZ2xlIFRlYW0uXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG5jb25zdCBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5jb25zdCBjbGFzc25hbWVzID0gcmVxdWlyZSgnY2xhc3NuYW1lcycpO1xuY29uc3QgSVNjcm9sbCA9IHJlcXVpcmUoJy4vaXNjcm9sbCcpO1xuY29uc3QgQ29udGV4dCA9IHJlcXVpcmUoJ0BhbGkvdGluZ2xlLWNvbnRleHQnKTtcblxuY2xhc3MgU2Nyb2xsZXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuICAgIH1cblxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICBsZXQgdCA9IHRoaXM7XG5cbiAgICAgICAgLy8g5qC56IqC54K555qEZG9t5byV55SoXG4gICAgICAgIHQuZWwgPSBSZWFjdERPTS5maW5kRE9NTm9kZSh0LnJlZnMucm9vdCk7XG5cbiAgICAgICAgLy8g5Yid5aeL5YyWIGlzY3JvbGxcbiAgICAgICAgdC5pbml0U2Nyb2xsKCk7XG4gICAgfVxuXG4gICAgY29tcG9uZW50RGlkVW5Nb3VudCgpIHtcblxuICAgICAgICAvLyDplIDmr4EgaXNjcm9sbFxuICAgICAgICB0aGlzLnNjcm9sbGVyLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgICAgIGxldCB0ID0gdGhpcztcblxuICAgICAgICAvLyDpgb/lhY3lvojpopHnuYHnmoTosIPnlKhcbiAgICAgICAgY2xlYXJUaW1lb3V0KHQuX3RpbWVvdXQpO1xuICAgICAgICB0Ll90aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIC8vIOacieS6m+WcuuaZr+S4i+S4jemcgOimgeWIt+aWsFxuICAgICAgICAgICAgaWYgKHQucHJvcHMuYXV0b1JlZnJlc2gpIHtcblxuICAgICAgICAgICAgICAgIC8vIOabtOaWsCBpc2Nyb2xsXG4gICAgICAgICAgICAgICAgdC5zY3JvbGxlciAmJiB0LnNjcm9sbGVyLnJlZnJlc2goKVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCAxMCk7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgdCA9IHRoaXM7XG5cbiAgICAgICAgLy8gaXNjcm9sbCDpnIDopoHkuIDkuKogd3JhcHBlcu+8jOaJgOS7pemHjOmdouWkmuWKoOS6huS4gOWxgiBkaXZcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjbGFzc25hbWVzKENvbnRleHQucHJlZml4Q2xhc3MoJ3Njcm9sbGVyJyksIHtcbiAgICAgICAgICAgICAgICBbdC5wcm9wcy5jbGFzc05hbWVdOiAhIXQucHJvcHMuY2xhc3NOYW1lXG4gICAgICAgICAgICB9KX0gcmVmPVwicm9vdFwiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtDb250ZXh0LnByZWZpeENsYXNzKCdESUInKX1cbiAgICAgICAgICAgICAgICAgICAgIHN0eWxlPXt7bWluV2lkdGg6IHQucHJvcHMubWluV2lkdGh9fT57dGhpcy5wcm9wcy5jaGlsZHJlbn08L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICApO1xuICAgIH1cblxuICAgIGluaXRTY3JvbGwoKSB7XG4gICAgICAgIGxldCB0ID0gdGhpcztcblxuICAgICAgICAvLyDlj4LmlbDov4fmu6TvvIxvblh4eCDmmK/kuovku7bvvIzlkKbliJnmmK/phY3nva7lj4LmlbBcbiAgICAgICAgbGV0IG9wdGlvbnMgPSB7fTtcbiAgICAgICAgbGV0IGV2ZW50cyA9IHt9O1xuICAgICAgICBmb3IgKGxldCBrZXkgaW4gdC5wcm9wcykge1xuICAgICAgICAgICAgbGV0IG1hdGNoZXMgPSAvXm9uKFtBLVpdXFx3KikkLy5leGVjKGtleSk7XG4gICAgICAgICAgICBpZiAobWF0Y2hlcykgeyAvLyDkuovku7ZcbiAgICAgICAgICAgICAgICBsZXQgZXZ0TmFtZSA9IG1hdGNoZXNbMV0ucmVwbGFjZSgvLi8sIGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZXZlbnRzW2V2dE5hbWVdID0gdC5wcm9wc1trZXldO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChrZXkgIT09ICdjbGFzc05hbWUnICYmIGtleSAhPT0gJ2F1dG9SZWZyZXNoJyAmJlxuICAgICAgICAgICAgICAgIGtleSAhPT0gJ21pbldpZHRoJykgeyAvLyDphY3nva5cbiAgICAgICAgICAgICAgICBvcHRpb25zW2tleV0gPSB0LnByb3BzW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpc2Nyb2xsIOWunuS+i+WMllxuICAgICAgICB0LnNjcm9sbGVyID0gbmV3IElTY3JvbGwodC5lbCwgb3B0aW9ucyk7XG5cbiAgICAgICAgLy8g5LqL5Lu25oyC6L29XG4gICAgICAgIGZvciAobGV0IGtleSBpbiBldmVudHMpIHtcbiAgICAgICAgICAgIHQuc2Nyb2xsZXIub24oa2V5LCBldmVudHNba2V5XS5iaW5kKG51bGwsIHQuc2Nyb2xsZXIpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8g5pu05aSa6YWN572u5Y+C5pWw77yM6K+m6KeBIGh0dHA6Ly9pc2Nyb2xsanMuY29tLyDvvIzkuovku7bnlKggb25YeHgg55qE5qC85byP77yM5L6L5aaCIHNjcm9sbEVuZCDkuovku7blr7nlupTnmoTlj4LmlbDmmK8gb25TY3JvbGxFbmRcblNjcm9sbGVyLmRlZmF1bHRQcm9wcyA9IHtcbiAgICBjbGljazogL2Nocm9tZS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCksIC8vaXNjcm9sbCDpu5jorqTlsY/olL3lhoXpg6jnmoQgY2xpY2sg5LqL5Lu277yM6ICD6JmR5Yiw5ZyoIGNocm9tZSDkuK3osIPor5XmsqHlvIDmqKHmi5/lmajnmoTlnLrmma/vvIzlhYHorrjlk43lupQgY2xpY2sg54K55Ye744CCIGh0dHA6Ly9pc2Nyb2xsanMuY29tLyNiYXNpYy1mZWF0dXJlc1xuICAgIGF1dG9SZWZyZXNoOiB0cnVlLFxuICAgIG1pbldpZHRoOiAnMTAwJSdcbn07XG5cbi8vIGh0dHA6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy9yZXVzYWJsZS1jb21wb25lbnRzLmh0bWxcblNjcm9sbGVyLnByb3BUeXBlcyA9IHtcbiAgICBhdXRvUmVmcmVzaDogUmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgY2xhc3NOYW1lOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNjcm9sbGVyO1xuIl0sInNvdXJjZVJvb3QiOiIvc291cmNlLyJ9
