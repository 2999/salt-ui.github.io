'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * CheckboxField Component for tingle
 * @author shanchao
 *
 * Copyright 2014-2016, Tingle Team.
 * All rights reserved.
 */
var React = require('react');
var classnames = require('classnames');
var Icon = require('@ali/tingle-icon');
var Context = require('@ali/tingle-context');
var Group = require('@ali/tingle-group');
var Field = require('@ali/tingle-field');
var SelectLayer = require('./SelectLayer');
var prefixClass = Context.prefixClass;

var CheckboxField = function (_React$Component) {
    _inherits(CheckboxField, _React$Component);

    function CheckboxField(props) {
        _classCallCheck(this, CheckboxField);

        var _this = _possibleConstructorReturn(this, (CheckboxField.__proto__ || Object.getPrototypeOf(CheckboxField)).call(this, props));

        var t = _this;
        t.state = {
            selectedText: ''
        };
        return _this;
    }

    _createClass(CheckboxField, [{
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            this.getSelectedText(nextProps.data);
        }
    }, {
        key: 'getSelectedText',
        value: function getSelectedText(data) {
            var _this2 = this;

            var selectedText = '';
            data.forEach(function (item) {
                if (item.checked) {
                    if (_this2.props.mode === 'list') {
                        selectedText = selectedText + '; ' + item.text;
                    } else {
                        selectedText = selectedText + '; ' + (item.slotText ? item.slotText : item.text);
                    }
                }
            });

            if (selectedText) {
                selectedText = selectedText.substring(2);
            }

            this.state.selectedText = selectedText;
        }
    }, {
        key: 'componentWillMount',
        value: function componentWillMount() {
            this.getSelectedText(this.props.data);
        }
    }, {
        key: 'getData',
        value: function getData() {
            var t = this;
            var data = [];

            t.props.data.forEach(function (item) {
                if (item.checked) {
                    data.push(item);
                }
            });

            return data;
        }
    }, {
        key: 'clickAction',
        value: function clickAction(value, item, index, data) {
            var t = this;
            var onChange = t.props.onChange;

            var disable = item.disable;
            if (t.props.readOnly || disable) {
                return;
            }
            item.checked = !item.checked;
            onChange && onChange(t.getData());
            t.forceUpdate();
        }
    }, {
        key: 'renderList',
        value: function renderList() {
            var _classnames2;

            var t = this;
            var props = t.props;
            var className = props.className,
                checkboxArray = props.data,
                groupListArgument = props.groupListArgument,
                groupListFlag = props.groupListFlag,
                label = props.label;

            var requiredTag = React.createElement(Icon, {
                name: 'field-required',
                className: prefixClass('field-layout-label-required'),
                width: 26,
                height: 26,
                fill: 'red'
            });

            var checkboxArrayComponent = checkboxArray.map(function (item, index, data) {
                var checked = item.checked,
                    disable = item.disable,
                    value = item.value;

                var iconName = checked ? "check-round" : "";
                var iconClassName = classnames(prefixClass("checkbox-field-icon"), { "checked": checked }, { "noChecked": !checked }, { "disable": disable }, _defineProperty({}, prefixClass("checkbox-field-icon") + '-list', true));

                var textClassName = classnames(prefixClass("checkbox-field-text FBH FBAC"), { "disable": disable });

                var iconTag = checked ? React.createElement(Icon, {
                    key: 'check-round',
                    width: 26,
                    height: 26,
                    name: 'check-round',
                    className: iconClassName
                }) : React.createElement('div', { className: iconClassName });

                var finalItemJSX = React.createElement(
                    'div',
                    {
                        onClick: t.clickAction.bind(t, value, item, index, checkboxArray),
                        key: index,
                        className: prefixClass("checkbox-field-row FBAC FBH")
                    },
                    React.createElement(
                        'div',
                        { className: prefixClass("checkbox-field-icon-div FBH FBAC") },
                        iconTag
                    ),
                    React.createElement(
                        'div',
                        { ref: "text" + index, className: textClassName },
                        item.text
                    )
                );
                return finalItemJSX;
            });

            var finalJSX = React.createElement(
                Group,
                { className: classnames(prefixClass('checkbox-field'), (_classnames2 = {}, _defineProperty(_classnames2, className, !!className), _defineProperty(_classnames2, prefixClass('checkbox-field-readonly'), !!t.props.readOnly), _classnames2)) },
                label == '' ? null : React.createElement(
                    Group.Head,
                    { className: classnames(prefixClass('checkbox-label')) },
                    label,
                    this.props.required && requiredTag
                ),
                React.createElement(
                    Group.List,
                    groupListArgument,
                    checkboxArrayComponent
                )
            );

            if (!groupListFlag) {
                var _classnames3;

                finalJSX = React.createElement(
                    'div',
                    { ref: 'root', className: classnames(prefixClass('checkbox-field'), (_classnames3 = {}, _defineProperty(_classnames3, className, !!className), _defineProperty(_classnames3, prefixClass('checkbox-field-readonly'), !!t.props.readOnly), _classnames3)) },
                    checkboxArrayComponent
                );
            }
            return finalJSX;
        }
    }, {
        key: 'handleClick',
        value: function handleClick() {
            !this.props.readOnly && this.refs.slot.show();
        }
    }, {
        key: 'handleCancel',
        value: function handleCancel() {}
    }, {
        key: 'handleConfirm',
        value: function handleConfirm(data) {
            this.state.value = data;
            this.getSelectedText(data);
            this.setState(this.state);
            this.props.onChange(data);
        }
    }, {
        key: 'renderSlot',
        value: function renderSlot() {
            var t = this;
            return React.createElement(
                Field,
                _extends({}, t.props, {
                    icon: {
                        className: classnames(prefixClass('checkbox-field-icon'), _defineProperty({}, prefixClass("checkbox-field-icon") + '-slot', true)),
                        name: 'angle-right',
                        width: 26,
                        height: 26,
                        onClick: t.handleClick.bind(t)
                    },
                    className: classnames(prefixClass('checkbox-field'), _defineProperty({}, t.props.className, !!t.props.className)) }),
                React.createElement(
                    'div',
                    { onClick: t.handleClick.bind(t), className: prefixClass('checkbox-field-value-wrap') },
                    t.state.selectedText ? React.createElement(
                        'div',
                        { className: prefixClass('checkbox-field-value-list') },
                        t.state.selectedText
                    ) : React.createElement(
                        'div',
                        { className: prefixClass('omit checkbox-field-placeholder') },
                        t.props.placeholder
                    )
                ),
                React.createElement(SelectLayer, { ref: 'slot', title: t.props.label,
                    confirmText: t.props.confirmText,
                    cancelText: t.props.cancelText,
                    data: t.props.data,
                    value: t.state.value,
                    maskCloseable: t.props.maskCloseable,
                    onCancel: t.handleCancel.bind(t),
                    onConfirm: t.handleConfirm.bind(t) })
            );
        }
    }, {
        key: 'render',
        value: function render() {
            return this.props.mode === 'list' ? this.renderList() : this.renderSlot();
        }
    }]);

    return CheckboxField;
}(React.Component);

CheckboxField.defaultProps = {
    mode: 'slot', // slot, list
    readOnly: false,
    label: '',
    data: [],
    onChange: function onChange() {},
    placeholder: '',
    maskCloseable: true,
    groupListFlag: true,
    groupListArgument: {
        lineIndent: 0,
        itemIndent: 15
    }
};

// http://facebook.github.io/react/docs/reusable-components.html
CheckboxField.propTypes = {
    className: React.PropTypes.string,
    mode: React.PropTypes.string,
    readOnly: React.PropTypes.bool,
    label: React.PropTypes.string,
    data: React.PropTypes.array,
    onChange: React.PropTypes.func,
    placeholder: React.PropTypes.string,
    maskCloseable: React.PropTypes.bool,
    groupListFlag: React.PropTypes.bool,
    groupListArgument: React.PropTypes.object
};

CheckboxField.displayName = 'CheckboxField';

module.exports = CheckboxField;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkNoZWNrYm94RmllbGQuanMiXSwibmFtZXMiOlsiUmVhY3QiLCJyZXF1aXJlIiwiY2xhc3NuYW1lcyIsIkljb24iLCJDb250ZXh0IiwiR3JvdXAiLCJGaWVsZCIsIlNlbGVjdExheWVyIiwicHJlZml4Q2xhc3MiLCJDaGVja2JveEZpZWxkIiwicHJvcHMiLCJ0Iiwic3RhdGUiLCJzZWxlY3RlZFRleHQiLCJuZXh0UHJvcHMiLCJnZXRTZWxlY3RlZFRleHQiLCJkYXRhIiwiZm9yRWFjaCIsIml0ZW0iLCJjaGVja2VkIiwibW9kZSIsInRleHQiLCJzbG90VGV4dCIsInN1YnN0cmluZyIsInB1c2giLCJ2YWx1ZSIsImluZGV4Iiwib25DaGFuZ2UiLCJkaXNhYmxlIiwicmVhZE9ubHkiLCJnZXREYXRhIiwiZm9yY2VVcGRhdGUiLCJjbGFzc05hbWUiLCJjaGVja2JveEFycmF5IiwiZ3JvdXBMaXN0QXJndW1lbnQiLCJncm91cExpc3RGbGFnIiwibGFiZWwiLCJyZXF1aXJlZFRhZyIsImNoZWNrYm94QXJyYXlDb21wb25lbnQiLCJtYXAiLCJpY29uTmFtZSIsImljb25DbGFzc05hbWUiLCJ0ZXh0Q2xhc3NOYW1lIiwiaWNvblRhZyIsImZpbmFsSXRlbUpTWCIsImNsaWNrQWN0aW9uIiwiYmluZCIsImZpbmFsSlNYIiwicmVxdWlyZWQiLCJyZWZzIiwic2xvdCIsInNob3ciLCJzZXRTdGF0ZSIsIm5hbWUiLCJ3aWR0aCIsImhlaWdodCIsIm9uQ2xpY2siLCJoYW5kbGVDbGljayIsInBsYWNlaG9sZGVyIiwiY29uZmlybVRleHQiLCJjYW5jZWxUZXh0IiwibWFza0Nsb3NlYWJsZSIsImhhbmRsZUNhbmNlbCIsImhhbmRsZUNvbmZpcm0iLCJyZW5kZXJMaXN0IiwicmVuZGVyU2xvdCIsIkNvbXBvbmVudCIsImRlZmF1bHRQcm9wcyIsImxpbmVJbmRlbnQiLCJpdGVtSW5kZW50IiwicHJvcFR5cGVzIiwiUHJvcFR5cGVzIiwic3RyaW5nIiwiYm9vbCIsImFycmF5Iiwi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b0JBQVk7QUFGRztBQVZNLENBQTdCOztBQWdCQTtBQUNBNUQsY0FBYzZELFNBQWQsR0FBMEI7QUFDdEJ0QyxlQUFXaEMsTUFBTXVFLFNBQU4sQ0FBZ0JDLE1BREw7QUFFdEJwRCxVQUFNcEIsTUFBTXVFLFNBQU4sQ0FBZ0JDLE1BRkE7QUFHdEIzQyxjQUFVN0IsTUFBTXVFLFNBQU4sQ0FBZ0JFLElBSEo7QUFJdEJyQyxXQUFPcEMsTUFBTXVFLFNBQU4sQ0FBZ0JDLE1BSkQ7QUFLdEJ4RCxVQUFNaEIsTUFBTXVFLFNBQU4sQ0FBZ0JHLEtBTEE7QUFNdEIvQyxjQUFVM0IsTUFBTXVFLFNBQU4sQ0FBZ0JJLElBTko7QUFPdEJqQixpQkFBYTFELE1BQU11RSxTQUFOLENBQWdCQyxNQVBQO0FBUXRCWCxtQkFBZTdELE1BQU11RSxTQUFOLENBQWdCRSxJQVJUO0FBU3RCdEMsbUJBQWVuQyxNQUFNdUUsU0FBTixDQUFnQkUsSUFUVDtBQVV0QnZDLHVCQUFtQmxDLE1BQU11RSxTQUFOLENBQWdCSztBQVZiLENBQTFCOztBQWFBbkUsY0FBY29FLFdBQWQsR0FBNEIsZUFBNUI7O0FBRUFDLE9BQU9DLE9BQVAsR0FBaUJ0RSxhQUFqQiIsImZpbGUiOiJDaGVja2JveEZpZWxkLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDaGVja2JveEZpZWxkIENvbXBvbmVudCBmb3IgdGluZ2xlXG4gKiBAYXV0aG9yIHNoYW5jaGFvXG4gKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNiwgVGluZ2xlIFRlYW0uXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG5jb25zdCBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5jb25zdCBjbGFzc25hbWVzID0gcmVxdWlyZSgnY2xhc3NuYW1lcycpO1xuY29uc3QgSWNvbiA9IHJlcXVpcmUoJ0BhbGkvdGluZ2xlLWljb24nKTtcbmNvbnN0IENvbnRleHQgPSByZXF1aXJlKCdAYWxpL3RpbmdsZS1jb250ZXh0Jyk7XG5jb25zdCBHcm91cCA9IHJlcXVpcmUoJ0BhbGkvdGluZ2xlLWdyb3VwJyk7XG5jb25zdCBGaWVsZCA9IHJlcXVpcmUoJ0BhbGkvdGluZ2xlLWZpZWxkJyk7XG5jb25zdCBTZWxlY3RMYXllciA9IHJlcXVpcmUoJy4vU2VsZWN0TGF5ZXInKTtcbmNvbnN0IHByZWZpeENsYXNzID0gQ29udGV4dC5wcmVmaXhDbGFzcztcblxuY2xhc3MgQ2hlY2tib3hGaWVsZCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG5cbiAgICAgICAgY29uc3QgdCA9IHRoaXM7XG4gICAgICAgIHQuc3RhdGUgPSB7XG4gICAgICAgICAgICBzZWxlY3RlZFRleHQ6ICcnXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAgICAgdGhpcy5nZXRTZWxlY3RlZFRleHQobmV4dFByb3BzLmRhdGEpO1xuICAgIH1cblxuICAgIGdldFNlbGVjdGVkVGV4dChkYXRhKSB7XG4gICAgICAgIGxldCBzZWxlY3RlZFRleHQgPSAnJztcbiAgICAgICAgZGF0YS5mb3JFYWNoKCBpdGVtID0+IHtcbiAgICAgICAgICAgIGlmIChpdGVtLmNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICBpZih0aGlzLnByb3BzLm1vZGUgPT09ICdsaXN0Jykge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZFRleHQgPSBzZWxlY3RlZFRleHQgKyAnOyAnICsgaXRlbS50ZXh0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkVGV4dCA9IHNlbGVjdGVkVGV4dCArICc7ICcgKyAoaXRlbS5zbG90VGV4dCA/IGl0ZW0uc2xvdFRleHQgOiBpdGVtLnRleHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHNlbGVjdGVkVGV4dCkge1xuICAgICAgICAgICAgc2VsZWN0ZWRUZXh0ID0gc2VsZWN0ZWRUZXh0LnN1YnN0cmluZygyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3RhdGUuc2VsZWN0ZWRUZXh0ID0gc2VsZWN0ZWRUZXh0O1xuICAgIH1cblxuICAgIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICAgICAgdGhpcy5nZXRTZWxlY3RlZFRleHQodGhpcy5wcm9wcy5kYXRhKTtcbiAgICB9XG5cbiAgICBnZXREYXRhKCkge1xuICAgICAgICBsZXQgdCA9IHRoaXM7XG4gICAgICAgIGxldCBkYXRhID0gW107XG5cbiAgICAgICAgdC5wcm9wcy5kYXRhLmZvckVhY2goIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICBpZiAoaXRlbS5jaGVja2VkKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBjbGlja0FjdGlvbih2YWx1ZSwgaXRlbSwgaW5kZXgsIGRhdGEpIHtcbiAgICAgICAgbGV0IHQgPSB0aGlzO1xuICAgICAgICBsZXQge29uQ2hhbmdlfSA9IHQucHJvcHM7XG4gICAgICAgIGxldCBkaXNhYmxlID0gaXRlbS5kaXNhYmxlO1xuICAgICAgICBpZiAodC5wcm9wcy5yZWFkT25seSB8fCBkaXNhYmxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaXRlbS5jaGVja2VkID0gIWl0ZW0uY2hlY2tlZDtcbiAgICAgICAgb25DaGFuZ2UgJiYgb25DaGFuZ2UodC5nZXREYXRhKCkpO1xuICAgICAgICB0LmZvcmNlVXBkYXRlKCk7XG4gICAgfVxuXG4gICAgcmVuZGVyTGlzdCgpIHtcbiAgICAgICAgbGV0IHQgPSB0aGlzO1xuICAgICAgICBsZXQgcHJvcHMgPSB0LnByb3BzO1xuICAgICAgICBsZXQge2NsYXNzTmFtZSwgZGF0YTpjaGVja2JveEFycmF5LCBncm91cExpc3RBcmd1bWVudCwgZ3JvdXBMaXN0RmxhZywgbGFiZWx9ID0gcHJvcHM7XG4gICAgICAgIGNvbnN0IHJlcXVpcmVkVGFnID0gKFxuICAgICAgICAgICAgPEljb25cbiAgICAgICAgICAgICAgICBuYW1lPVwiZmllbGQtcmVxdWlyZWRcIlxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17cHJlZml4Q2xhc3MoJ2ZpZWxkLWxheW91dC1sYWJlbC1yZXF1aXJlZCcpfVxuICAgICAgICAgICAgICAgIHdpZHRoPXsyNn1cbiAgICAgICAgICAgICAgICBoZWlnaHQ9ezI2fVxuICAgICAgICAgICAgICAgIGZpbGw9XCJyZWRcIlxuICAgICAgICAgICAgLz5cbiAgICAgICAgKTtcblxuICAgICAgICBsZXQgY2hlY2tib3hBcnJheUNvbXBvbmVudCA9IGNoZWNrYm94QXJyYXkubWFwKGZ1bmN0aW9uIChpdGVtLCBpbmRleCwgZGF0YSkge1xuICAgICAgICAgICAgbGV0IHtjaGVja2VkLGRpc2FibGUsIHZhbHVlfSA9IGl0ZW07XG4gICAgICAgICAgICBsZXQgaWNvbk5hbWUgPSBjaGVja2VkID8gXCJjaGVjay1yb3VuZFwiIDogXCJcIjtcbiAgICAgICAgICAgIGxldCBpY29uQ2xhc3NOYW1lID0gY2xhc3NuYW1lcyhcbiAgICAgICAgICAgICAgICBwcmVmaXhDbGFzcyhcImNoZWNrYm94LWZpZWxkLWljb25cIiksXG4gICAgICAgICAgICAgICAge1wiY2hlY2tlZFwiOiBjaGVja2VkfSxcbiAgICAgICAgICAgICAgICB7XCJub0NoZWNrZWRcIjogIWNoZWNrZWR9LFxuICAgICAgICAgICAgICAgIHtcImRpc2FibGVcIjogZGlzYWJsZX0sXG4gICAgICAgICAgICAgICAge1twcmVmaXhDbGFzcyhcImNoZWNrYm94LWZpZWxkLWljb25cIikgKyAnLWxpc3QnXTogdHJ1ZX1cbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGxldCB0ZXh0Q2xhc3NOYW1lID0gY2xhc3NuYW1lcyhcbiAgICAgICAgICAgICAgICBwcmVmaXhDbGFzcyhcImNoZWNrYm94LWZpZWxkLXRleHQgRkJIIEZCQUNcIiksXG4gICAgICAgICAgICAgICAge1wiZGlzYWJsZVwiOiBkaXNhYmxlfVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgbGV0IGljb25UYWcgPSBjaGVja2VkID9cbiAgICAgICAgICAgICAgICA8SWNvblxuICAgICAgICAgICAgICAgICAgICBrZXk9XCJjaGVjay1yb3VuZFwiXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoPXsyNn1cbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0PXsyNn1cbiAgICAgICAgICAgICAgICAgICAgbmFtZT1cImNoZWNrLXJvdW5kXCJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtpY29uQ2xhc3NOYW1lfVxuICAgICAgICAgICAgICAgIC8+IDogPGRpdiBjbGFzc05hbWU9e2ljb25DbGFzc05hbWV9PjwvZGl2PjtcblxuICAgICAgICAgICAgbGV0IGZpbmFsSXRlbUpTWCA9IChcbiAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e3QuY2xpY2tBY3Rpb24uYmluZCh0LCB2YWx1ZSwgaXRlbSxpbmRleCwgY2hlY2tib3hBcnJheSl9XG4gICAgICAgICAgICAgICAgICAgIGtleT17aW5kZXh9XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17cHJlZml4Q2xhc3MoXCJjaGVja2JveC1maWVsZC1yb3cgRkJBQyBGQkhcIil9XG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17cHJlZml4Q2xhc3MoXCJjaGVja2JveC1maWVsZC1pY29uLWRpdiBGQkggRkJBQ1wiKX0+XG4gICAgICAgICAgICAgICAgICAgICAgICB7aWNvblRhZ31cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgcmVmPXtcInRleHRcIiArIGluZGV4fSBjbGFzc05hbWU9e3RleHRDbGFzc05hbWV9PntpdGVtLnRleHR9PC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIGZpbmFsSXRlbUpTWFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG5cblxuICAgICAgICBsZXQgZmluYWxKU1ggPSAoXG4gICAgICAgICAgICA8R3JvdXAgY2xhc3NOYW1lPXtjbGFzc25hbWVzKHByZWZpeENsYXNzKCdjaGVja2JveC1maWVsZCcpLCB7XG4gICAgICAgICAgICAgICAgW2NsYXNzTmFtZV06ICEhY2xhc3NOYW1lLFxuICAgICAgICAgICAgICAgIFtwcmVmaXhDbGFzcygnY2hlY2tib3gtZmllbGQtcmVhZG9ubHknKV06ICEhdC5wcm9wcy5yZWFkT25seVxuICAgICAgICAgICAgfSl9PlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwgPT0gJycgPyBudWxsIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIDxHcm91cC5IZWFkIGNsYXNzTmFtZT17Y2xhc3NuYW1lcyhwcmVmaXhDbGFzcygnY2hlY2tib3gtbGFiZWwnKSl9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtsYWJlbH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7dGhpcy5wcm9wcy5yZXF1aXJlZCAmJiByZXF1aXJlZFRhZ31cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvR3JvdXAuSGVhZD5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgPEdyb3VwLkxpc3Qgey4uLmdyb3VwTGlzdEFyZ3VtZW50fSA+XG4gICAgICAgICAgICAgICAgICAgIHtjaGVja2JveEFycmF5Q29tcG9uZW50fVxuICAgICAgICAgICAgICAgIDwvR3JvdXAuTGlzdD5cbiAgICAgICAgICAgIDwvR3JvdXA+XG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKCFncm91cExpc3RGbGFnKSB7XG4gICAgICAgICAgICBmaW5hbEpTWCA9IChcbiAgICAgICAgICAgICAgICA8ZGl2IHJlZj0ncm9vdCcgY2xhc3NOYW1lPXtjbGFzc25hbWVzKHByZWZpeENsYXNzKCdjaGVja2JveC1maWVsZCcpLCB7XG4gICAgICAgICAgICAgICAgICAgIFtjbGFzc05hbWVdOiAhIWNsYXNzTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgW3ByZWZpeENsYXNzKCdjaGVja2JveC1maWVsZC1yZWFkb25seScpXTogISF0LnByb3BzLnJlYWRPbmx5XG4gICAgICAgICAgICAgICAgfSl9PlxuICAgICAgICAgICAgICAgICAgICB7Y2hlY2tib3hBcnJheUNvbXBvbmVudH1cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmluYWxKU1g7XG4gICAgfVxuXG4gICAgaGFuZGxlQ2xpY2soKSB7XG4gICAgICAgICF0aGlzLnByb3BzLnJlYWRPbmx5ICYmIHRoaXMucmVmcy5zbG90LnNob3coKTtcbiAgICB9XG5cbiAgICBoYW5kbGVDYW5jZWwoKSB7XG4gICAgfVxuXG4gICAgaGFuZGxlQ29uZmlybShkYXRhKSB7XG4gICAgICAgIHRoaXMuc3RhdGUudmFsdWUgPSBkYXRhO1xuICAgICAgICB0aGlzLmdldFNlbGVjdGVkVGV4dChkYXRhKTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh0aGlzLnN0YXRlKTtcbiAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZShkYXRhKTtcbiAgICB9XG5cbiAgICByZW5kZXJTbG90KCkge1xuICAgICAgICBjb25zdCB0ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxGaWVsZFxuICAgICAgICAgICAgICAgIHsuLi50LnByb3BzfVxuICAgICAgICAgICAgICAgIGljb249e3tcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBjbGFzc25hbWVzKFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZml4Q2xhc3MoJ2NoZWNrYm94LWZpZWxkLWljb24nKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtbcHJlZml4Q2xhc3MoXCJjaGVja2JveC1maWVsZC1pY29uXCIpICsgJy1zbG90J106IHRydWV9XG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdhbmdsZS1yaWdodCcsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiAyNixcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAyNixcbiAgICAgICAgICAgICAgICAgICAgb25DbGljazogdC5oYW5kbGVDbGljay5iaW5kKHQpXG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzbmFtZXMocHJlZml4Q2xhc3MoJ2NoZWNrYm94LWZpZWxkJyksIHtcbiAgICAgICAgICAgICAgICAgICAgW3QucHJvcHMuY2xhc3NOYW1lXTogISF0LnByb3BzLmNsYXNzTmFtZVxuICAgICAgICAgICAgICAgIH0pfT5cbiAgICAgICAgICAgICAgICA8ZGl2IG9uQ2xpY2s9e3QuaGFuZGxlQ2xpY2suYmluZCh0KX0gY2xhc3NOYW1lPXtwcmVmaXhDbGFzcygnY2hlY2tib3gtZmllbGQtdmFsdWUtd3JhcCcpfT5cbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdC5zdGF0ZS5zZWxlY3RlZFRleHQgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtwcmVmaXhDbGFzcygnY2hlY2tib3gtZmllbGQtdmFsdWUtbGlzdCcpfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3Quc3RhdGUuc2VsZWN0ZWRUZXh0fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PiA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3ByZWZpeENsYXNzKCdvbWl0IGNoZWNrYm94LWZpZWxkLXBsYWNlaG9sZGVyJyl9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7dC5wcm9wcy5wbGFjZWhvbGRlcn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDxTZWxlY3RMYXllciByZWY9XCJzbG90XCIgdGl0bGU9e3QucHJvcHMubGFiZWx9XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpcm1UZXh0PXt0LnByb3BzLmNvbmZpcm1UZXh0fVxuICAgICAgICAgICAgICAgICAgICBjYW5jZWxUZXh0PXt0LnByb3BzLmNhbmNlbFRleHR9XG4gICAgICAgICAgICAgICAgICAgIGRhdGE9e3QucHJvcHMuZGF0YX1cbiAgICAgICAgICAgICAgICAgICAgdmFsdWU9e3Quc3RhdGUudmFsdWV9XG4gICAgICAgICAgICAgICAgICAgIG1hc2tDbG9zZWFibGU9e3QucHJvcHMubWFza0Nsb3NlYWJsZX1cbiAgICAgICAgICAgICAgICAgICAgb25DYW5jZWw9e3QuaGFuZGxlQ2FuY2VsLmJpbmQodCl9XG4gICAgICAgICAgICAgICAgICAgIG9uQ29uZmlybT17dC5oYW5kbGVDb25maXJtLmJpbmQodCl9Lz5cbiAgICAgICAgICAgIDwvRmllbGQ+XG4gICAgICAgIClcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BzLm1vZGUgPT09ICdsaXN0JyA/IHRoaXMucmVuZGVyTGlzdCgpIDogdGhpcy5yZW5kZXJTbG90KCk7XG4gICAgfVxufVxuXG5DaGVja2JveEZpZWxkLmRlZmF1bHRQcm9wcyA9IHtcbiAgICBtb2RlOiAnc2xvdCcsIC8vIHNsb3QsIGxpc3RcbiAgICByZWFkT25seTogZmFsc2UsXG4gICAgbGFiZWw6JycsXG4gICAgZGF0YTogW10sXG4gICAgb25DaGFuZ2U6IGZ1bmN0aW9uICgpIHtcbiAgICB9LFxuICAgIHBsYWNlaG9sZGVyOiAnJyxcbiAgICBtYXNrQ2xvc2VhYmxlOiB0cnVlLFxuICAgIGdyb3VwTGlzdEZsYWc6IHRydWUsXG4gICAgZ3JvdXBMaXN0QXJndW1lbnQ6IHtcbiAgICAgICAgbGluZUluZGVudDogMCxcbiAgICAgICAgaXRlbUluZGVudDogMTVcbiAgICB9XG59O1xuXG4vLyBodHRwOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvcmV1c2FibGUtY29tcG9uZW50cy5odG1sXG5DaGVja2JveEZpZWxkLnByb3BUeXBlcyA9IHtcbiAgICBjbGFzc05hbWU6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgbW9kZTogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICByZWFkT25seTogUmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgbGFiZWw6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgZGF0YTogUmVhY3QuUHJvcFR5cGVzLmFycmF5LFxuICAgIG9uQ2hhbmdlOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBwbGFjZWhvbGRlcjogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBtYXNrQ2xvc2VhYmxlOiBSZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBncm91cExpc3RGbGFnOiBSZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBncm91cExpc3RBcmd1bWVudDogUmVhY3QuUHJvcFR5cGVzLm9iamVjdFxufTtcblxuQ2hlY2tib3hGaWVsZC5kaXNwbGF5TmFtZSA9ICdDaGVja2JveEZpZWxkJztcblxubW9kdWxlLmV4cG9ydHMgPSBDaGVja2JveEZpZWxkO1xuIl0sInNvdXJjZVJvb3QiOiIvc291cmNlLyJ9
