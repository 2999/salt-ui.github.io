'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
* Slide Component for tingle
* @author gnosaij,cm
*
* Copyright 2014-2016, Tingle Team, Alinw.
* All rights reserved.
*/
var React = require('react');
var classnames = require('classnames');
var Context = require('@ali/tingle-context');
var SlideNav = require('./SlideNav');

var prefixClass = function prefixClass(name) {
    return Context.prefixClass ? Context.prefixClass(name) : 't-' + name;
};

var TOUCH_START = Context.TOUCH_START;
var TOUCH_MOVE = Context.TOUCH_MOVE;
var TOUCH_END = Context.TOUCH_END;
var TOUCH_CANCEL = Context.TOUCH_CANCEL;
var support3D = Context.support3D;
var supportTouch = Context.supportTouch;
var isPC = Context.isPC;
var noop = Context.noop;
var RESIZE = Context.RESIZE;


var win = window;
var doc = document;
var OFFSET = 'offset';
var POS_MAP = {
    '-1': '_prevEl',
    '0': '_currentEl',
    '1': '_nextEl'
};

// 创建translate字符串
// TODO: translate(0,0) translateZ(0);
var makeTranslate = function () {
    var prefix = support3D ? 'translate3d(' : 'translate(';
    var suffix = support3D ? ', 0)' : ')';
    var join = ',';

    function v(n) {
        n = '' + (n || 0);
        n = n.indexOf('%') > -1 ? n : n + 'px';
        return n;
    }

    return function (x, y) {
        return prefix + v(x) + join + v(y) + suffix;
    };
}();

// 获取兼容PC和Device的event对象的page属性
var getCursorPage = supportTouch ? function (event, page) {
    return event.changedTouches[0][page];
} : function (event, page) {
    return event[page];
};

var Slide = function (_React$Component) {
    _inherits(Slide, _React$Component);

    function Slide(props) {
        _classCallCheck(this, Slide);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Slide).call(this, props));

        var t = _this;

        // 切换动画的时长
        _this.duration = 200;

        // 能够触发切换的偏移量
        _this.effectiveDelta = Math.floor(window.innerWidth / 1.8);

        // 当偏移量不足时，使用速度来决定是否移动 单位：px/s
        _this.speed = 300;

        _this.state = {
            auto: props.auto,
            // 当前item的索引值 以0开始
            index: props.active,
            disabled: false
        };

        // 当屏幕旋转的时候，修正布局
        win.addEventListener(RESIZE, t, false);
        return _this;
    }

    _createClass(Slide, [{
        key: 'componentWillMount',
        value: function componentWillMount() {
            var t = this;
            t._getLength();
        }
    }, {
        key: 'componentDidMount',
        value: function componentDidMount() {
            var t = this;

            t.el = t.refs.root;

            // 确定容器宽度
            t.width = isPC ? t.el.clientWidth : win.innerWidth;

            t._setContext();
        }
    }, {
        key: 'componentDidUpdate',
        value: function componentDidUpdate(prevProps) {
            var t = this;
            var oldChildrenLength = prevProps.children.length;
            var newChildrenLength = this.props.children.length;
            if (newChildrenLength != oldChildrenLength) {
                t._getLength();
                t._setContext(prevProps);
            }
        }
    }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
            var t = this;
            if (t.length > 1) {
                t.el.removeEventListener(TOUCH_START, t, false);
            }
            win.removeEventListener(RESIZE, t, false);
            clearTimeout(t._autoSlideTimer);
        }

        /**
        * 获取 slide 列表的真正长度，主要是考虑 children
        * 长度是 1 和 2 的情况下
        */

    }, {
        key: '_getLength',
        value: function _getLength() {
            var t = this;
            var originLength = React.Children.count(t.props.children);

            // TODO: check
            if (originLength === 1) {
                t.setState({
                    disabled: true
                });
            }

            // item的长度经处理后不存在为2的情况
            else if (originLength === 2) {
                    t._dummy = true;
                    t._realIndex = {
                        '0': 0,
                        '1': 1,
                        '2': 0,
                        '3': 1
                    };
                }

            // 处理以后的长度，即item的个数
            t.length = t._dummy ? 4 : originLength;
        }

        /**
        * 根据 slide 列表长度设置正确的内部变量
        *
        */

    }, {
        key: '_setContext',
        value: function _setContext(prevProps) {
            var t = this;

            // 由于子元素数量有变化，先解绑与数量相关的监听，再根据数量重新绑定。
            t.el.removeEventListener(TOUCH_START, t, false);
            clearTimeout(t._autoSlideTimer);

            // 至少有2张slide时，才初始化事件
            if (t.length > 1) {
                t.el.addEventListener(TOUCH_START, t, false);
            } else {
                t.el.addEventListener('click', function () {
                    t.props.onSlideClick({
                        index: 0,
                        item: t._currentEl,
                        data: t.props.children[0]
                    });
                });
            }

            // 前一个，当前的，后一个item的element引用
            t._prevEl = null;
            t._currentEl = null;
            t._nextEl = null;

            t._deltaX = 0;
            t._minIndex = 0;
            t._maxIndex = t.length - 1;
            if (!prevProps) {
                t.props.onMount(t);
            } else {
                t.setState({
                    index: t.props.index
                });
            }
            if (t.length != 0) {
                t._goto(t.state.index, true);
                t._autoSlide();
            }
        }
    }, {
        key: '_autoSlide',
        value: function _autoSlide() {
            var t = this;
            if (!t.state.auto) return;
            t._autoSlideTimer = setTimeout(function () {
                t.goNext();
                t._autoSlide();
            }, 4000);
        }

        /**
        * @param {number} index 目标位置的索引值
        * @param {boolean} callFromDidMount 是否是在 componentDidMount 中被调用的
        */

    }, {
        key: '_goto',
        value: function _goto(posIndex, callFromDidMount) {
            var t = this;
            callFromDidMount = !!callFromDidMount;

            if (t.length === 1 || callFromDidMount) {
                // `_getItemReady` 方法被调用之前，需要先更新 `currentPosIndex` 的值
                t.currentPosIndex = posIndex;
                t._getItemReady(0);

                if (t.length > 2) {
                    t._getItemReady(1);
                    t._getItemReady(-1);
                }

                t._slideEnd();
            } else if (!callFromDidMount) {

                // 通过goNext/goPrev调用的_goto，一直有方向(_dir)值 向左:-1 / 向右:1
                if (t._dir) {
                    t._getItemUnready(t._dir === 1 ? t._nextEl : t._prevEl);
                    t._moveItem(t._currentEl, t._dir);
                    t._moveItem(t._dir === 1 ? t._prevEl : t._nextEl, t._dir);

                    // `_getItemReady`方法被调用之前，需要先更新`currentPosIndex`的值
                    t.currentPosIndex = posIndex;
                    t._getItemReady(t._dir * -1);

                    setTimeout(function () {
                        t._slideEnd();
                    }, t.duration);
                }

                // 归位的情况：移动距离小于有效距离时
                else if (posIndex === t.currentPosIndex) {
                        // 归位当前item
                        t._moveItem(t._currentEl, 0);
                        // 归位进入屏幕的另一个item
                        // 说明:任意一个时间点,出现在屏幕内的item数量最多为2个,要么左边,要么右边,取决于移动方向
                        if (t._moveBack) {
                            t._moveItem(t._moveBack, 0);
                        }
                        // 当resize时
                        else {
                                t._moveItem(t._prevEl, 0);
                                t._moveItem(t._nextEl, 0);
                            }
                    }
            }

            t._moveBack = null;
            t._dir = null;
        }
    }, {
        key: 'goNext',
        value: function goNext() {
            var t = this;
            // 方向是向左(-1)，要展现的是后一张(1)
            t._dir = -1;
            t._goto(t._getPosIndex(1));
        }
    }, {
        key: 'goPrev',
        value: function goPrev() {
            var t = this;
            // 方向是向右(1)，要展现的是前一张(-1)
            t._dir = 1;
            t._goto(t._getPosIndex(-1));
        }

        /**
        * 移动item到新的位置
        * @param {element} item
        * @param {number} dir 移动的方向 -1:向左移动 / 1:向右移动 / 0:移动到原位
        */

    }, {
        key: '_moveItem',
        value: function _moveItem(item, dir) {
            var t = this;
            item.style.webkitTransitionDuration = t.duration + 'ms';

            var newOffset = +item.getAttribute(OFFSET) + dir;

            t._setItemX(item, t._getPosX(newOffset));

            // 如果进行了切换行为，即dir为-1或1
            if (dir) {
                item.setAttribute(OFFSET, newOffset);
                t[POS_MAP[newOffset]] = item;
            }
        }

        /**
        * 根据指定的偏移量，找到对应的item，将其切换到可移动状态
        * @param {number} offset -1:前一个位置 / 0:当前位置 / 1: 后一个位置
        * @note 任何时刻，可移动状态的item数量只有三个
        * @note 该方法依赖`currentPosIndex`和`offset`查找目标`item`，
        *       而`_getItemUnready`方法直接给定了`item`，不需要依赖`currentPosIndex`和`offset`
        */

    }, {
        key: '_getItemReady',
        value: function _getItemReady(offset) {
            var t = this;
            var targetPosIndex = t._getPosIndex(offset);
            var item = t.refs['item' + targetPosIndex];
            item.classList.add('ready');
            item.setAttribute(OFFSET, offset);
            item.style.webkitTransform = makeTranslate(t._getPosX(offset));
            t[POS_MAP[offset]] = item;
        }

        /**
        * 将指定的item切换到不可移动状态，即不参与切换行为。
        * @param {element} item 要改变状态的item
        * @note 这个函数虽然含义上和_setItemReady对应，但参数直接只用item，
        *  是出于性能考虑，因为调用该函数的时候，都是明确知道目标item的。
        */

    }, {
        key: '_getItemUnready',
        value: function _getItemUnready(item) {
            var t = this;
            item.classList.remove('ready');
            item.removeAttribute(OFFSET);
            item.style.webkitTransitionDuration = '0';
            item.style.webkitTransform = 'none';
        }

        /**
        * 获取指定的offset所对应的X坐标值(0点在当前item的左边缘)
        * @param {number} offset -1:前一个位置 / 0:当前位置 / 1: 后一个位置
        */

    }, {
        key: '_getPosX',
        value: function _getPosX(offset) {
            var t = this;
            return offset === -1 ? -t.width : offset === 1 ? t.width : 0;
        }

        /**
        *
        */

    }, {
        key: '_setItemX',
        value: function _setItemX(item, x) {
            this[POS_MAP[item.getAttribute(OFFSET)] + 'X'] = x;
            item.style.webkitTransform = makeTranslate(x);
        }

        /**
        * 获取前一个或后一个位置的索引值，相对值是currentPosIndex
        * @param {number} offset -1:取前一个位置 / 0:取当前位置 / 1: 取后一个位置
        */

    }, {
        key: '_getPosIndex',
        value: function _getPosIndex(offset) {
            var t = this,
                index = void 0;
            if (offset === -1) {
                index = t.currentPosIndex === t._minIndex ? t._maxIndex : t.currentPosIndex - 1;
            } else if (offset === 1) {
                index = t.currentPosIndex === t._maxIndex ? t._minIndex : t.currentPosIndex + 1;
            } else if (offset === 0) {
                index = t.currentPosIndex;
            } else {
                throw new Error('error offset');
            }
            return index;
        }
    }, {
        key: 'handleEvent',
        value: function handleEvent(e) {
            var t = this;
            switch (e.type) {
                case TOUCH_START:
                    t._touchStart(e);
                    break;
                case TOUCH_MOVE:
                    t._touchMove(e);
                    break;
                case TOUCH_END:
                    t._touchEnd(e);
                    break;
                case TOUCH_CANCEL:
                    t._touchEnd(e);
                case RESIZE:
                    t._resize(e);
                    break;
            }
        }
    }, {
        key: '_touchStart',
        value: function _touchStart(e) {
            // 只响应单指操作
            if (supportTouch && e.touches.length > 1) {
                return;
            }

            var t = this;

            clearTimeout(t._autoSlideTimer);

            // 恢复到0 拖拽过程中快速响应移动距离
            t._prevEl.style.webkitTransitionDuration = '0ms';
            t._currentEl.style.webkitTransitionDuration = '0ms';
            t._nextEl.style.webkitTransitionDuration = '0ms';

            // 移动初始值
            t._prevElX = t._getPosX(-1);
            t._currentElX = t._getPosX(0);
            t._nextElX = t._getPosX(1);

            // 浏览器默认滚动
            t.browserScrolling = false;

            // 是否是切换状态 此时忽略浏览器默认的滚动行为
            t.sliding = false;

            t.startPageX = getCursorPage(e, 'pageX');
            t.startPageY = getCursorPage(e, 'pageY');
            t.basePageX = t.startPageX;
            t.startTime = e.timeStamp;

            doc.addEventListener(TOUCH_MOVE, t, false);
            doc.addEventListener(TOUCH_END, t, false);
        }
    }, {
        key: '_touchMove',
        value: function _touchMove(e) {
            // 只响应单指操作
            if (supportTouch && e.touches.length > 1) {
                return;
            }

            var t = this;

            // 如果浏览器默认滚动行为已被触发，则不执行Slider的滚动
            if (t.browserScrolling) {
                return;
            }

            var pageX = getCursorPage(e, 'pageX'),
                pageY = getCursorPage(e, 'pageY'),
                distX = void 0,
                newPrevX = void 0,
                newCurrentX = void 0,
                newNextX = void 0,
                deltaY = void 0;

            t.deltaX = pageX - t.startPageX;

            // 如果slide开始滚动
            if (t.sliding) {
                e.preventDefault();
                e.stopPropagation();

                // 任意时刻的位移值
                distX = pageX - t.basePageX;

                // 当不是循环模式的时候，第一张和最后一张添加粘性
                if (t.props.loop === false && (distX >= 0 && t.currentPosIndex === t._minIndex || distX < 0 && t.currentPosIndex === t._maxIndex || distX < 0 && t._dummy && t.currentPosIndex === 1)) {
                    distX = distX - distX / 1.3;
                }

                // 位移后的X坐标
                newPrevX = t._prevElX + distX;
                newCurrentX = t._currentElX + distX;
                newNextX = t._nextElX + distX;

                // 更新DOM位置
                t._setItemX(t._prevEl, newPrevX);
                t._setItemX(t._currentEl, newCurrentX);
                t._setItemX(t._nextEl, newNextX);

                if (t.deltaX >= 0) {
                    t._moveBack = t._prevEl;
                } else {
                    t._moveBack = t._nextEl;
                }
            } else {
                deltaY = pageY - t.startPageY;

                // 如果X轴的移动距离先达到5px，则执行Slider的滚动
                // 如果Y轴的移动距离先达到5px，则执行浏览器默认的页面滚动
                if (Math.abs(t.deltaX) > 5) {
                    e.preventDefault();
                    e.stopPropagation();
                    t.sliding = true;
                } else if (Math.abs(deltaY) > 5) {
                    t.browserScrolling = true;
                }
            }

            t.basePageX = pageX;
        }
    }, {
        key: '_touchEnd',
        value: function _touchEnd(e) {
            // 只响应单指操作
            if (supportTouch && e.touches.length > 1) {
                return;
            }

            var t = this;

            // 如果浏览器默认滚动行为已被触发，则不执行Slider的滚动
            if (t.browserScrolling) {
                return;
            }

            t.browserScrolling = false;

            var endTime = e.timeStamp;
            var speed = Math.floor(t.deltaX / (t.startTime - endTime) * 1000);

            // 向右滑动
            if (t.deltaX > t.effectiveDelta || speed < -t.speed) {
                if (t.props.loop === false && t.currentPosIndex === t._minIndex) {
                    t._goto(t.currentPosIndex);
                } else {
                    t.goPrev();
                }
            }

            // 向左滑动
            else if (t.deltaX < -t.effectiveDelta || speed > t.speed) {
                    if (t.props.loop === false && (t.currentPosIndex === t._maxIndex || t._dummy && t.currentPosIndex === 1)) {
                        t._goto(t.currentPosIndex);
                    } else {
                        t.goNext();
                    }
                }

                // 点击
                else if (endTime - t.startTime < 500 && Math.abs(t.deltaX >> 0) < 5) {
                        t._slideClick();
                    }

                    // 保持原有位置
                    else {
                            t._goto(t.currentPosIndex);
                        }

            t.deltaX = 0;

            doc.removeEventListener(TOUCH_MOVE, t, false);
            doc.removeEventListener(TOUCH_END, t, false);

            t._autoSlide();
        }
    }, {
        key: '_slideClick',
        value: function _slideClick() {
            var t = this;
            var realIndex = t._getRealIndex(t.currentPosIndex);
            t.props.onSlideClick({
                index: realIndex,
                item: t._currentEl,
                data: t.props.children[realIndex]
            });
        }
    }, {
        key: '_slideEnd',
        value: function _slideEnd() {
            var t = this;
            var realIndex = t._getRealIndex(t.currentPosIndex);
            t.props.onSlideEnd({
                index: realIndex,
                item: t._currentEl,
                data: t.props.children[realIndex]
            });
            // https://facebook.github.io/react/docs/component-api.html#forceupdate
            // 通常情况下我们不使用 forcecUpdate，但我们需要 slide 过程中的中间变量
            // 而非最终 state 去触发插件的更新，因此这里我们用到了 forceUpdate。
            t.forceUpdate();
        }
    }, {
        key: '_getRealIndex',
        value: function _getRealIndex(posIndex) {
            var t = this;
            return t._dummy ? t._realIndex[posIndex] : posIndex;
        }

        /**
        * 当屏幕旋转时，更新基本数据 && 再次定位
        */

    }, {
        key: '_resize',
        value: function _resize() {
            var t = this;
            t.width = isPC ? t.el.clientWidth : win.innerWidth;
            t._goto(t.currentPosIndex);
        }

        /**
        * 渲染items 当item数量为2时，该方法会被调用两次，第二次函数为true，以实现循环轮播
        * @param {boolean} dummyMode 是否是在渲染补位的item，
        * @note 只有当`props.children`的长度为2时，才需要进行补位
        */

    }, {
        key: '_renderItems',
        value: function _renderItems(dummyMode) {
            var t = this;
            return t.props.children.map(function (Child, index) {
                return React.createElement(
                    'div',
                    { ref: "item" + (index + (dummyMode ? 2 : 0)), key: index + (dummyMode ? 2 : 0),
                        className: prefixClass('slide-item') + ' ' + prefixClass('slide-item') + t._getRealIndex(index) },
                    Child
                );
            });
        }
    }, {
        key: 'render',
        value: function render() {
            var _classnames;

            var t = this;
            return React.createElement(
                'div',
                { ref: 'root', className: classnames((_classnames = {}, _defineProperty(_classnames, '' + prefixClass('slide'), true), _defineProperty(_classnames, '' + prefixClass('slide-off'), t.state.disabled), _defineProperty(_classnames, t.props.className, !!t.props.className), _classnames)) },
                React.createElement(
                    'div',
                    { className: prefixClass('3D') + ' ' + prefixClass('slide-view'), style: { height: t.props.height } },
                    t._renderItems(),
                    t._dummy && t._renderItems(true)
                ),
                t.props.showNav && t.length > 1 && React.createElement(SlideNav, { active: t._getRealIndex(t.currentPosIndex), num: t.props.children.length })
            );
        }
    }]);

    return Slide;
}(React.Component);

Slide.propTypes = {
    className: React.PropTypes.string,
    height: React.PropTypes.oneOfType([React.PropTypes.number, React.PropTypes.string]),
    active: React.PropTypes.number,
    auto: React.PropTypes.bool,
    loop: React.PropTypes.bool,
    showNav: React.PropTypes.bool,
    onMount: React.PropTypes.func,
    onSlideEnd: React.PropTypes.func,
    onSlideClick: React.PropTypes.func
};

Slide.defaultProps = {
    height: '5rem',
    active: 0,
    auto: false,
    loop: true,
    showNav: false,
    onMount: noop,
    onSlideEnd: noop,
    onSlideClick: noop
};

Slide.displayName = 'Slide';

module.exports = Slide;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlNsaWRlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFPQSxJQUFNLFFBQVEsUUFBUSxPQUFSLENBQVI7QUFDTixJQUFNLGFBQWEsUUFBUSxZQUFSLENBQWI7QUFDTixJQUFNLFVBQVUsUUFBUSxxQkFBUixDQUFWO0FBQ04sSUFBTSxXQUFXLFFBQVEsWUFBUixDQUFYOztBQUVOLElBQU0sY0FBYyxTQUFkLFdBQWMsQ0FBUyxJQUFULEVBQWU7QUFDL0IsV0FBTyxRQUFRLFdBQVIsR0FBc0IsUUFBUSxXQUFSLENBQW9CLElBQXBCLENBQXRCLEdBQWtELE9BQU8sSUFBUCxDQUQxQjtDQUFmOztJQUtoQixjQVNBLFFBVEE7SUFDQSxhQVFBLFFBUkE7SUFDQSxZQU9BLFFBUEE7SUFDQSxlQU1BLFFBTkE7SUFDQSxZQUtBLFFBTEE7SUFDQSxlQUlBLFFBSkE7SUFDQSxPQUdBLFFBSEE7SUFDQSxPQUVBLFFBRkE7SUFDQSxTQUNBLFFBREE7OztBQUdKLElBQUksTUFBTSxNQUFOO0FBQ0osSUFBSSxNQUFNLFFBQU47QUFDSixJQUFJLFNBQVMsUUFBVDtBQUNKLElBQUksVUFBVTtBQUNWLFVBQU0sU0FBTjtBQUNBLFNBQUssWUFBTDtBQUNBLFNBQUssU0FBTDtDQUhBOzs7O0FBUUosSUFBSSxnQkFBZ0IsWUFBYTtBQUM3QixRQUFJLFNBQVMsWUFBWSxjQUFaLEdBQTZCLFlBQTdCLENBRGdCO0FBRTdCLFFBQUksU0FBUyxZQUFZLE1BQVosR0FBcUIsR0FBckIsQ0FGZ0I7QUFHN0IsUUFBSSxPQUFPLEdBQVAsQ0FIeUI7O0FBSzdCLGFBQVMsQ0FBVCxDQUFXLENBQVgsRUFBYztBQUNWLFlBQUksTUFBTSxLQUFLLENBQUwsQ0FBTixDQURNO0FBRVYsWUFBSSxFQUFFLE9BQUYsQ0FBVSxHQUFWLElBQWlCLENBQUMsQ0FBRCxHQUFLLENBQXRCLEdBQTBCLElBQUksSUFBSixDQUZwQjtBQUdWLGVBQU8sQ0FBUCxDQUhVO0tBQWQ7O0FBTUEsV0FBTyxVQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCO0FBQ25CLGVBQU8sU0FBUyxFQUFFLENBQUYsQ0FBVCxHQUFnQixJQUFoQixHQUF1QixFQUFFLENBQUYsQ0FBdkIsR0FBOEIsTUFBOUIsQ0FEWTtLQUFoQixDQVhzQjtDQUFaLEVBQWpCOzs7QUFpQkosSUFBSSxnQkFBZ0IsZUFBZSxVQUFVLEtBQVYsRUFBaUIsSUFBakIsRUFBdUI7QUFDdEQsV0FBTyxNQUFNLGNBQU4sQ0FBcUIsQ0FBckIsRUFBd0IsSUFBeEIsQ0FBUCxDQURzRDtDQUF2QixHQUUvQixVQUFVLEtBQVYsRUFBaUIsSUFBakIsRUFBdUI7QUFDdkIsV0FBTyxNQUFNLElBQU4sQ0FBUCxDQUR1QjtDQUF2Qjs7SUFJRTs7O0FBRUYsYUFGRSxLQUVGLENBQVksS0FBWixFQUFtQjs4QkFGakIsT0FFaUI7OzJFQUZqQixrQkFHUSxRQURTOztBQUVmLFlBQUksU0FBSjs7O0FBRmUsYUFLZixDQUFLLFFBQUwsR0FBZ0IsR0FBaEI7OztBQUxlLGFBUWYsQ0FBSyxjQUFMLEdBQXNCLEtBQUssS0FBTCxDQUFXLE9BQU8sVUFBUCxHQUFvQixHQUFwQixDQUFqQzs7O0FBUmUsYUFXZixDQUFLLEtBQUwsR0FBYSxHQUFiLENBWGU7O0FBYWYsY0FBSyxLQUFMLEdBQWE7QUFDVCxrQkFBTSxNQUFNLElBQU47O0FBRU4sbUJBQU8sTUFBTSxNQUFOO0FBQ1Asc0JBQVUsS0FBVjtTQUpKOzs7QUFiZSxXQXFCZixDQUFJLGdCQUFKLENBQXFCLE1BQXJCLEVBQTZCLENBQTdCLEVBQWdDLEtBQWhDLEVBckJlOztLQUFuQjs7aUJBRkU7OzZDQTBCbUI7QUFDakIsZ0JBQUksSUFBSSxJQUFKLENBRGE7QUFFakIsY0FBRSxVQUFGLEdBRmlCOzs7OzRDQUtEO0FBQ2hCLGdCQUFJLElBQUksSUFBSixDQURZOztBQUdoQixjQUFFLEVBQUYsR0FBTyxFQUFFLElBQUYsQ0FBTyxJQUFQOzs7QUFIUyxhQU1oQixDQUFFLEtBQUYsR0FBVSxPQUFPLEVBQUUsRUFBRixDQUFLLFdBQUwsR0FBbUIsSUFBSSxVQUFKLENBTnBCOztBQVFoQixjQUFFLFdBQUYsR0FSZ0I7Ozs7MkNBV0QsV0FBVztBQUMxQixnQkFBSSxJQUFJLElBQUosQ0FEc0I7QUFFMUIsZ0JBQUksb0JBQW9CLFVBQVUsUUFBVixDQUFtQixNQUFuQixDQUZFO0FBRzFCLGdCQUFJLG9CQUFvQixLQUFLLEtBQUwsQ0FBVyxRQUFYLENBQW9CLE1BQXBCLENBSEU7QUFJMUIsZ0JBQUkscUJBQXFCLGlCQUFyQixFQUF3QztBQUN4QyxrQkFBRSxVQUFGLEdBRHdDO0FBRXhDLGtCQUFFLFdBQUYsQ0FBYyxTQUFkLEVBRndDO2FBQTVDOzs7OytDQU1tQjtBQUNuQixnQkFBSSxJQUFJLElBQUosQ0FEZTtBQUVuQixnQkFBSSxFQUFFLE1BQUYsR0FBVyxDQUFYLEVBQWM7QUFDZCxrQkFBRSxFQUFGLENBQUssbUJBQUwsQ0FBeUIsV0FBekIsRUFBc0MsQ0FBdEMsRUFBeUMsS0FBekMsRUFEYzthQUFsQjtBQUdBLGdCQUFJLG1CQUFKLENBQXdCLE1BQXhCLEVBQWdDLENBQWhDLEVBQW1DLEtBQW5DLEVBTG1CO0FBTW5CLHlCQUFhLEVBQUUsZUFBRixDQUFiLENBTm1COzs7Ozs7Ozs7O3FDQWFWO0FBQ1QsZ0JBQUksSUFBSSxJQUFKLENBREs7QUFFVCxnQkFBSSxlQUFlLE1BQU0sUUFBTixDQUFlLEtBQWYsQ0FBcUIsRUFBRSxLQUFGLENBQVEsUUFBUixDQUFwQzs7O0FBRkssZ0JBS0wsaUJBQWlCLENBQWpCLEVBQW9CO0FBQ3BCLGtCQUFFLFFBQUYsQ0FBVztBQUNQLDhCQUFVLElBQVY7aUJBREosRUFEb0I7Ozs7QUFBeEIsaUJBT0ssSUFBSSxpQkFBaUIsQ0FBakIsRUFBb0I7QUFDekIsc0JBQUUsTUFBRixHQUFXLElBQVgsQ0FEeUI7QUFFekIsc0JBQUUsVUFBRixHQUFlO0FBQ1gsNkJBQUssQ0FBTDtBQUNBLDZCQUFLLENBQUw7QUFDQSw2QkFBSyxDQUFMO0FBQ0EsNkJBQUssQ0FBTDtxQkFKSixDQUZ5QjtpQkFBeEI7OztBQVpJLGFBdUJULENBQUUsTUFBRixHQUFXLEVBQUUsTUFBRixHQUFXLENBQVgsR0FBZSxZQUFmLENBdkJGOzs7Ozs7Ozs7O29DQThCRCxXQUFXO0FBQ25CLGdCQUFJLElBQUksSUFBSjs7O0FBRGUsYUFJbkIsQ0FBRSxFQUFGLENBQUssbUJBQUwsQ0FBeUIsV0FBekIsRUFBc0MsQ0FBdEMsRUFBeUMsS0FBekMsRUFKbUI7QUFLbkIseUJBQWEsRUFBRSxlQUFGLENBQWI7OztBQUxtQixnQkFRZixFQUFFLE1BQUYsR0FBVyxDQUFYLEVBQWM7QUFDZCxrQkFBRSxFQUFGLENBQUssZ0JBQUwsQ0FBc0IsV0FBdEIsRUFBbUMsQ0FBbkMsRUFBc0MsS0FBdEMsRUFEYzthQUFsQixNQUVPO0FBQ0gsa0JBQUUsRUFBRixDQUFLLGdCQUFMLENBQXNCLE9BQXRCLEVBQStCLFlBQVU7QUFDckMsc0JBQUUsS0FBRixDQUFRLFlBQVIsQ0FBcUI7QUFDakIsK0JBQU8sQ0FBUDtBQUNBLDhCQUFNLEVBQUUsVUFBRjtBQUNOLDhCQUFNLEVBQUUsS0FBRixDQUFRLFFBQVIsQ0FBaUIsQ0FBakIsQ0FBTjtxQkFISixFQURxQztpQkFBVixDQUEvQixDQURHO2FBRlA7OztBQVJtQixhQXFCbkIsQ0FBRSxPQUFGLEdBQVksSUFBWixDQXJCbUI7QUFzQm5CLGNBQUUsVUFBRixHQUFlLElBQWYsQ0F0Qm1CO0FBdUJuQixjQUFFLE9BQUYsR0FBWSxJQUFaLENBdkJtQjs7QUF5Qm5CLGNBQUUsT0FBRixHQUFZLENBQVosQ0F6Qm1CO0FBMEJuQixjQUFFLFNBQUYsR0FBYyxDQUFkLENBMUJtQjtBQTJCbkIsY0FBRSxTQUFGLEdBQWMsRUFBRSxNQUFGLEdBQVcsQ0FBWCxDQTNCSztBQTRCbkIsZ0JBQUksQ0FBQyxTQUFELEVBQVk7QUFDWixrQkFBRSxLQUFGLENBQVEsT0FBUixDQUFnQixDQUFoQixFQURZO2FBQWhCLE1BR0s7QUFDRCxrQkFBRSxRQUFGLENBQVc7QUFDUCwyQkFBTyxFQUFFLEtBQUYsQ0FBUSxLQUFSO2lCQURYLEVBREM7YUFITDtBQVFBLGdCQUFJLEVBQUUsTUFBRixJQUFZLENBQVosRUFBZTtBQUNmLGtCQUFFLEtBQUYsQ0FBUSxFQUFFLEtBQUYsQ0FBUSxLQUFSLEVBQWUsSUFBdkIsRUFEZTtBQUVmLGtCQUFFLFVBQUYsR0FGZTthQUFuQjs7OztxQ0FNUztBQUNULGdCQUFJLElBQUksSUFBSixDQURLO0FBRVQsZ0JBQUksQ0FBQyxFQUFFLEtBQUYsQ0FBUSxJQUFSLEVBQWMsT0FBbkI7QUFDQSxjQUFFLGVBQUYsR0FBb0IsV0FBVyxZQUFZO0FBQ3ZDLGtCQUFFLE1BQUYsR0FEdUM7QUFFdkMsa0JBQUUsVUFBRixHQUZ1QzthQUFaLEVBRzVCLElBSGlCLENBQXBCLENBSFM7Ozs7Ozs7Ozs7OEJBYVAsVUFBVSxrQkFBa0I7QUFDOUIsZ0JBQUksSUFBSSxJQUFKLENBRDBCO0FBRTlCLCtCQUFtQixDQUFDLENBQUMsZ0JBQUQsQ0FGVTs7QUFJOUIsZ0JBQUksRUFBRSxNQUFGLEtBQWEsQ0FBYixJQUFrQixnQkFBbEIsRUFBb0M7O0FBRXBDLGtCQUFFLGVBQUYsR0FBb0IsUUFBcEIsQ0FGb0M7QUFHcEMsa0JBQUUsYUFBRixDQUFnQixDQUFoQixFQUhvQzs7QUFLcEMsb0JBQUksRUFBRSxNQUFGLEdBQVcsQ0FBWCxFQUFjO0FBQ2Qsc0JBQUUsYUFBRixDQUFnQixDQUFoQixFQURjO0FBRWQsc0JBQUUsYUFBRixDQUFnQixDQUFDLENBQUQsQ0FBaEIsQ0FGYztpQkFBbEI7O0FBS0Esa0JBQUUsU0FBRixHQVZvQzthQUF4QyxNQVdPLElBQUksQ0FBQyxnQkFBRCxFQUFtQjs7O0FBRzFCLG9CQUFJLEVBQUUsSUFBRixFQUFRO0FBQ1Isc0JBQUUsZUFBRixDQUFrQixFQUFFLElBQUYsS0FBVyxDQUFYLEdBQWUsRUFBRSxPQUFGLEdBQVksRUFBRSxPQUFGLENBQTdDLENBRFE7QUFFUixzQkFBRSxTQUFGLENBQVksRUFBRSxVQUFGLEVBQWMsRUFBRSxJQUFGLENBQTFCLENBRlE7QUFHUixzQkFBRSxTQUFGLENBQVksRUFBRSxJQUFGLEtBQVcsQ0FBWCxHQUFlLEVBQUUsT0FBRixHQUFZLEVBQUUsT0FBRixFQUFXLEVBQUUsSUFBRixDQUFsRDs7O0FBSFEscUJBTVIsQ0FBRSxlQUFGLEdBQW9CLFFBQXBCLENBTlE7QUFPUixzQkFBRSxhQUFGLENBQWdCLEVBQUUsSUFBRixHQUFTLENBQUMsQ0FBRCxDQUF6QixDQVBROztBQVNSLCtCQUFXLFlBQVk7QUFDbkIsMEJBQUUsU0FBRixHQURtQjtxQkFBWixFQUVSLEVBQUUsUUFBRixDQUZILENBVFE7Ozs7QUFBWixxQkFlSyxJQUFJLGFBQWEsRUFBRSxlQUFGLEVBQW1COztBQUVyQywwQkFBRSxTQUFGLENBQVksRUFBRSxVQUFGLEVBQWMsQ0FBMUI7OztBQUZxQyw0QkFLakMsRUFBRSxTQUFGLEVBQWE7QUFDYiw4QkFBRSxTQUFGLENBQVksRUFBRSxTQUFGLEVBQWEsQ0FBekIsRUFEYTs7O0FBQWpCLDZCQUlLO0FBQ0Qsa0NBQUUsU0FBRixDQUFZLEVBQUUsT0FBRixFQUFXLENBQXZCLEVBREM7QUFFRCxrQ0FBRSxTQUFGLENBQVksRUFBRSxPQUFGLEVBQVcsQ0FBdkIsRUFGQzs2QkFKTDtxQkFMQzthQWxCRjs7QUFrQ1AsY0FBRSxTQUFGLEdBQWMsSUFBZCxDQWpEOEI7QUFrRDlCLGNBQUUsSUFBRixHQUFTLElBQVQsQ0FsRDhCOzs7O2lDQXFEekI7QUFDTCxnQkFBSSxJQUFJLElBQUo7O0FBREMsYUFHTCxDQUFFLElBQUYsR0FBUyxDQUFDLENBQUQsQ0FISjtBQUlMLGNBQUUsS0FBRixDQUFRLEVBQUUsWUFBRixDQUFlLENBQWYsQ0FBUixFQUpLOzs7O2lDQU9BO0FBQ0wsZ0JBQUksSUFBSSxJQUFKOztBQURDLGFBR0wsQ0FBRSxJQUFGLEdBQVMsQ0FBVCxDQUhLO0FBSUwsY0FBRSxLQUFGLENBQVEsRUFBRSxZQUFGLENBQWUsQ0FBQyxDQUFELENBQXZCLEVBSks7Ozs7Ozs7Ozs7O2tDQVlDLE1BQU0sS0FBSztBQUNqQixnQkFBSSxJQUFJLElBQUosQ0FEYTtBQUVqQixpQkFBSyxLQUFMLENBQVcsd0JBQVgsR0FBc0MsRUFBRSxRQUFGLEdBQWEsSUFBYixDQUZyQjs7QUFJakIsZ0JBQUksWUFBWSxDQUFDLEtBQUssWUFBTCxDQUFrQixNQUFsQixDQUFELEdBQTZCLEdBQTdCLENBSkM7O0FBTWpCLGNBQUUsU0FBRixDQUFZLElBQVosRUFBa0IsRUFBRSxRQUFGLENBQVcsU0FBWCxDQUFsQjs7O0FBTmlCLGdCQVNiLEdBQUosRUFBUztBQUNMLHFCQUFLLFlBQUwsQ0FBa0IsTUFBbEIsRUFBMEIsU0FBMUIsRUFESztBQUVMLGtCQUFFLFFBQVEsU0FBUixDQUFGLElBQXdCLElBQXhCLENBRks7YUFBVDs7Ozs7Ozs7Ozs7OztzQ0FhVSxRQUFRO0FBQ2xCLGdCQUFJLElBQUksSUFBSixDQURjO0FBRWxCLGdCQUFJLGlCQUFpQixFQUFFLFlBQUYsQ0FBZSxNQUFmLENBQWpCLENBRmM7QUFHbEIsZ0JBQUksT0FBTyxFQUFFLElBQUYsQ0FBTyxTQUFTLGNBQVQsQ0FBZCxDQUhjO0FBSWxCLGlCQUFLLFNBQUwsQ0FBZSxHQUFmLENBQW1CLE9BQW5CLEVBSmtCO0FBS2xCLGlCQUFLLFlBQUwsQ0FBa0IsTUFBbEIsRUFBMEIsTUFBMUIsRUFMa0I7QUFNbEIsaUJBQUssS0FBTCxDQUFXLGVBQVgsR0FBNkIsY0FBYyxFQUFFLFFBQUYsQ0FBVyxNQUFYLENBQWQsQ0FBN0IsQ0FOa0I7QUFPbEIsY0FBRSxRQUFRLE1BQVIsQ0FBRixJQUFxQixJQUFyQixDQVBrQjs7Ozs7Ozs7Ozs7O3dDQWdCTixNQUFNO0FBQ2xCLGdCQUFJLElBQUksSUFBSixDQURjO0FBRWxCLGlCQUFLLFNBQUwsQ0FBZSxNQUFmLENBQXNCLE9BQXRCLEVBRmtCO0FBR2xCLGlCQUFLLGVBQUwsQ0FBcUIsTUFBckIsRUFIa0I7QUFJbEIsaUJBQUssS0FBTCxDQUFXLHdCQUFYLEdBQXNDLEdBQXRDLENBSmtCO0FBS2xCLGlCQUFLLEtBQUwsQ0FBVyxlQUFYLEdBQTZCLE1BQTdCLENBTGtCOzs7Ozs7Ozs7O2lDQVliLFFBQVE7QUFDYixnQkFBSSxJQUFJLElBQUosQ0FEUztBQUViLG1CQUFPLFdBQVcsQ0FBQyxDQUFELEdBQUssQ0FBQyxFQUFFLEtBQUYsR0FBVSxXQUFXLENBQVgsR0FBZSxFQUFFLEtBQUYsR0FBVSxDQUF6QixDQUZyQjs7Ozs7Ozs7O2tDQVFQLE1BQU0sR0FBRztBQUNmLGlCQUFLLFFBQVEsS0FBSyxZQUFMLENBQWtCLE1BQWxCLENBQVIsSUFBcUMsR0FBckMsQ0FBTCxHQUFpRCxDQUFqRCxDQURlO0FBRWYsaUJBQUssS0FBTCxDQUFXLGVBQVgsR0FBNkIsY0FBYyxDQUFkLENBQTdCLENBRmU7Ozs7Ozs7Ozs7cUNBU04sUUFBUTtBQUNqQixnQkFBSSxJQUFJLElBQUo7Z0JBQVUsY0FBZCxDQURpQjtBQUVqQixnQkFBSSxXQUFXLENBQUMsQ0FBRCxFQUFJO0FBQ2Ysd0JBQVEsRUFBRSxlQUFGLEtBQXNCLEVBQUUsU0FBRixHQUFjLEVBQUUsU0FBRixHQUFjLEVBQUUsZUFBRixHQUFvQixDQUFwQixDQUQzQzthQUFuQixNQUVPLElBQUksV0FBVyxDQUFYLEVBQWM7QUFDckIsd0JBQVEsRUFBRSxlQUFGLEtBQXNCLEVBQUUsU0FBRixHQUFjLEVBQUUsU0FBRixHQUFjLEVBQUUsZUFBRixHQUFvQixDQUFwQixDQURyQzthQUFsQixNQUVBLElBQUksV0FBVyxDQUFYLEVBQWM7QUFDckIsd0JBQVEsRUFBRSxlQUFGLENBRGE7YUFBbEIsTUFFQTtBQUNILHNCQUFNLElBQUksS0FBSixDQUFVLGNBQVYsQ0FBTixDQURHO2FBRkE7QUFLUCxtQkFBTyxLQUFQLENBWGlCOzs7O29DQWNULEdBQUc7QUFDWCxnQkFBSSxJQUFJLElBQUosQ0FETztBQUVYLG9CQUFRLEVBQUUsSUFBRjtBQUNKLHFCQUFLLFdBQUw7QUFDQSxzQkFBRSxXQUFGLENBQWMsQ0FBZCxFQURBO0FBRUEsMEJBRkE7QUFESixxQkFJUyxVQUFMO0FBQ0Esc0JBQUUsVUFBRixDQUFhLENBQWIsRUFEQTtBQUVBLDBCQUZBO0FBSkoscUJBT1MsU0FBTDtBQUNBLHNCQUFFLFNBQUYsQ0FBWSxDQUFaLEVBREE7QUFFQSwwQkFGQTtBQVBKLHFCQVVTLFlBQUw7QUFDQSxzQkFBRSxTQUFGLENBQVksQ0FBWixFQURBO0FBVkoscUJBWVMsTUFBTDtBQUNBLHNCQUFFLE9BQUYsQ0FBVSxDQUFWLEVBREE7QUFFQSwwQkFGQTtBQVpKLGFBRlc7Ozs7b0NBb0JILEdBQUc7O0FBRVgsZ0JBQUksZ0JBQWdCLEVBQUUsT0FBRixDQUFVLE1BQVYsR0FBbUIsQ0FBbkIsRUFBc0I7QUFDdEMsdUJBRHNDO2FBQTFDOztBQUlBLGdCQUFJLElBQUksSUFBSixDQU5POztBQVFYLHlCQUFhLEVBQUUsZUFBRixDQUFiOzs7QUFSVyxhQVdYLENBQUUsT0FBRixDQUFVLEtBQVYsQ0FBZ0Isd0JBQWhCLEdBQTJDLEtBQTNDLENBWFc7QUFZWCxjQUFFLFVBQUYsQ0FBYSxLQUFiLENBQW1CLHdCQUFuQixHQUE4QyxLQUE5QyxDQVpXO0FBYVgsY0FBRSxPQUFGLENBQVUsS0FBVixDQUFnQix3QkFBaEIsR0FBMkMsS0FBM0M7OztBQWJXLGFBZ0JYLENBQUUsUUFBRixHQUFhLEVBQUUsUUFBRixDQUFXLENBQUMsQ0FBRCxDQUF4QixDQWhCVztBQWlCWCxjQUFFLFdBQUYsR0FBZ0IsRUFBRSxRQUFGLENBQVcsQ0FBWCxDQUFoQixDQWpCVztBQWtCWCxjQUFFLFFBQUYsR0FBYSxFQUFFLFFBQUYsQ0FBVyxDQUFYLENBQWI7OztBQWxCVyxhQXFCWCxDQUFFLGdCQUFGLEdBQXFCLEtBQXJCOzs7QUFyQlcsYUF3QlgsQ0FBRSxPQUFGLEdBQVksS0FBWixDQXhCVzs7QUEwQlgsY0FBRSxVQUFGLEdBQWUsY0FBYyxDQUFkLEVBQWlCLE9BQWpCLENBQWYsQ0ExQlc7QUEyQlgsY0FBRSxVQUFGLEdBQWUsY0FBYyxDQUFkLEVBQWlCLE9BQWpCLENBQWYsQ0EzQlc7QUE0QlgsY0FBRSxTQUFGLEdBQWMsRUFBRSxVQUFGLENBNUJIO0FBNkJYLGNBQUUsU0FBRixHQUFjLEVBQUUsU0FBRixDQTdCSDs7QUErQlgsZ0JBQUksZ0JBQUosQ0FBcUIsVUFBckIsRUFBaUMsQ0FBakMsRUFBb0MsS0FBcEMsRUEvQlc7QUFnQ1gsZ0JBQUksZ0JBQUosQ0FBcUIsU0FBckIsRUFBZ0MsQ0FBaEMsRUFBbUMsS0FBbkMsRUFoQ1c7Ozs7bUNBbUNKLEdBQUc7O0FBRVYsZ0JBQUksZ0JBQWdCLEVBQUUsT0FBRixDQUFVLE1BQVYsR0FBbUIsQ0FBbkIsRUFBc0I7QUFDdEMsdUJBRHNDO2FBQTFDOztBQUlBLGdCQUFJLElBQUksSUFBSjs7O0FBTk0sZ0JBU04sRUFBRSxnQkFBRixFQUFvQjtBQUNwQix1QkFEb0I7YUFBeEI7O0FBSUEsZ0JBQUksUUFBUSxjQUFjLENBQWQsRUFBaUIsT0FBakIsQ0FBUjtnQkFDSixRQUFRLGNBQWMsQ0FBZCxFQUFpQixPQUFqQixDQUFSO2dCQUNBLGNBRkE7Z0JBR0EsaUJBSEE7Z0JBSUEsb0JBSkE7Z0JBS0EsaUJBTEE7Z0JBTUEsZUFOQSxDQWJVOztBQXFCVixjQUFFLE1BQUYsR0FBVyxRQUFRLEVBQUUsVUFBRjs7O0FBckJULGdCQXdCTixFQUFFLE9BQUYsRUFBVztBQUNYLGtCQUFFLGNBQUYsR0FEVztBQUVYLGtCQUFFLGVBQUY7OztBQUZXLHFCQUtYLEdBQVEsUUFBUSxFQUFFLFNBQUY7OztBQUxMLG9CQVFQLEVBQUUsS0FBRixDQUFRLElBQVIsS0FBaUIsS0FBakIsS0FBMkIsS0FBQyxJQUFTLENBQVQsSUFBYyxFQUFFLGVBQUYsS0FBc0IsRUFBRSxTQUFGLElBQWlCLFFBQVEsQ0FBUixJQUFhLEVBQUUsZUFBRixLQUFzQixFQUFFLFNBQUYsSUFBaUIsUUFBUSxDQUFSLElBQWEsRUFBRSxNQUFGLElBQVksRUFBRSxlQUFGLEtBQXNCLENBQXRCLENBQTlKLEVBQXlMO0FBQ3pMLDRCQUFRLFFBQVEsUUFBUSxHQUFSLENBRHlLO2lCQUE3TDs7O0FBUlcsd0JBYVgsR0FBVyxFQUFFLFFBQUYsR0FBYSxLQUFiLENBYkE7QUFjWCw4QkFBYyxFQUFFLFdBQUYsR0FBZ0IsS0FBaEIsQ0FkSDtBQWVYLDJCQUFXLEVBQUUsUUFBRixHQUFhLEtBQWI7OztBQWZBLGlCQWtCWCxDQUFFLFNBQUYsQ0FBWSxFQUFFLE9BQUYsRUFBVyxRQUF2QixFQWxCVztBQW1CWCxrQkFBRSxTQUFGLENBQVksRUFBRSxVQUFGLEVBQWMsV0FBMUIsRUFuQlc7QUFvQlgsa0JBQUUsU0FBRixDQUFZLEVBQUUsT0FBRixFQUFXLFFBQXZCLEVBcEJXOztBQXNCWCxvQkFBSSxFQUFFLE1BQUYsSUFBWSxDQUFaLEVBQWU7QUFDZixzQkFBRSxTQUFGLEdBQWMsRUFBRSxPQUFGLENBREM7aUJBQW5CLE1BRU87QUFDSCxzQkFBRSxTQUFGLEdBQWMsRUFBRSxPQUFGLENBRFg7aUJBRlA7YUF0QkosTUEyQk87QUFDSCx5QkFBUyxRQUFRLEVBQUUsVUFBRjs7OztBQURkLG9CQUtDLEtBQUssR0FBTCxDQUFTLEVBQUUsTUFBRixDQUFULEdBQXFCLENBQXJCLEVBQXdCO0FBQ3hCLHNCQUFFLGNBQUYsR0FEd0I7QUFFeEIsc0JBQUUsZUFBRixHQUZ3QjtBQUd4QixzQkFBRSxPQUFGLEdBQVksSUFBWixDQUh3QjtpQkFBNUIsTUFJTyxJQUFJLEtBQUssR0FBTCxDQUFTLE1BQVQsSUFBbUIsQ0FBbkIsRUFBc0I7QUFDN0Isc0JBQUUsZ0JBQUYsR0FBcUIsSUFBckIsQ0FENkI7aUJBQTFCO2FBcENYOztBQXlDQSxjQUFFLFNBQUYsR0FBYyxLQUFkLENBakVVOzs7O2tDQW9FSixHQUFHOztBQUVULGdCQUFJLGdCQUFnQixFQUFFLE9BQUYsQ0FBVSxNQUFWLEdBQW1CLENBQW5CLEVBQXNCO0FBQ3RDLHVCQURzQzthQUExQzs7QUFJQSxnQkFBSSxJQUFJLElBQUo7OztBQU5LLGdCQVNMLEVBQUUsZ0JBQUYsRUFBb0I7QUFDcEIsdUJBRG9CO2FBQXhCOztBQUlBLGNBQUUsZ0JBQUYsR0FBcUIsS0FBckIsQ0FiUzs7QUFlVCxnQkFBSSxVQUFVLEVBQUUsU0FBRixDQWZMO0FBZ0JULGdCQUFJLFFBQVEsS0FBSyxLQUFMLENBQVcsRUFBRSxNQUFGLElBQVUsRUFBRSxTQUFGLEdBQWMsT0FBZCxDQUFWLEdBQW1DLElBQW5DLENBQW5COzs7QUFoQkssZ0JBbUJMLEVBQUUsTUFBRixHQUFXLEVBQUUsY0FBRixJQUFvQixRQUFRLENBQUMsRUFBRSxLQUFGLEVBQVM7QUFDakQsb0JBQUksRUFBRSxLQUFGLENBQVEsSUFBUixLQUFpQixLQUFqQixJQUEwQixFQUFFLGVBQUYsS0FBc0IsRUFBRSxTQUFGLEVBQWE7QUFDN0Qsc0JBQUUsS0FBRixDQUFRLEVBQUUsZUFBRixDQUFSLENBRDZEO2lCQUFqRSxNQUVPO0FBQ0gsc0JBQUUsTUFBRixHQURHO2lCQUZQOzs7O0FBREosaUJBU0ssSUFBSSxFQUFFLE1BQUYsR0FBVyxDQUFDLEVBQUUsY0FBRixJQUFvQixRQUFRLEVBQUUsS0FBRixFQUFTO0FBQ3RELHdCQUFJLEVBQUUsS0FBRixDQUFRLElBQVIsS0FBaUIsS0FBakIsS0FBMkIsRUFBRSxlQUFGLEtBQXNCLEVBQUUsU0FBRixJQUFnQixFQUFFLE1BQUYsSUFBWSxFQUFFLGVBQUYsS0FBc0IsQ0FBdEIsQ0FBN0UsRUFBd0c7QUFDeEcsMEJBQUUsS0FBRixDQUFRLEVBQUUsZUFBRixDQUFSLENBRHdHO3FCQUE1RyxNQUVPO0FBQ0gsMEJBQUUsTUFBRixHQURHO3FCQUZQOzs7O0FBREMscUJBU0EsSUFBSSxVQUFVLEVBQUUsU0FBRixHQUFjLEdBQXhCLElBQStCLEtBQUssR0FBTCxDQUFTLEVBQUUsTUFBRixJQUFVLENBQVYsQ0FBVCxHQUF3QixDQUF4QixFQUEyQjtBQUMvRCwwQkFBRSxXQUFGLEdBRCtEOzs7O0FBQTlELHlCQUtBO0FBQ0QsOEJBQUUsS0FBRixDQUFRLEVBQUUsZUFBRixDQUFSLENBREM7eUJBTEE7O0FBU0wsY0FBRSxNQUFGLEdBQVcsQ0FBWCxDQTlDUzs7QUFnRFQsZ0JBQUksbUJBQUosQ0FBd0IsVUFBeEIsRUFBb0MsQ0FBcEMsRUFBdUMsS0FBdkMsRUFoRFM7QUFpRFQsZ0JBQUksbUJBQUosQ0FBd0IsU0FBeEIsRUFBbUMsQ0FBbkMsRUFBc0MsS0FBdEMsRUFqRFM7O0FBbURULGNBQUUsVUFBRixHQW5EUzs7OztzQ0FzREM7QUFDVixnQkFBSSxJQUFJLElBQUosQ0FETTtBQUVWLGdCQUFJLFlBQVksRUFBRSxhQUFGLENBQWdCLEVBQUUsZUFBRixDQUE1QixDQUZNO0FBR1YsY0FBRSxLQUFGLENBQVEsWUFBUixDQUFxQjtBQUNqQix1QkFBTyxTQUFQO0FBQ0Esc0JBQU0sRUFBRSxVQUFGO0FBQ04sc0JBQU0sRUFBRSxLQUFGLENBQVEsUUFBUixDQUFpQixTQUFqQixDQUFOO2FBSEosRUFIVTs7OztvQ0FVRjtBQUNSLGdCQUFJLElBQUksSUFBSixDQURJO0FBRVIsZ0JBQUksWUFBWSxFQUFFLGFBQUYsQ0FBZ0IsRUFBRSxlQUFGLENBQTVCLENBRkk7QUFHUixjQUFFLEtBQUYsQ0FBUSxVQUFSLENBQW1CO0FBQ2YsdUJBQU8sU0FBUDtBQUNBLHNCQUFNLEVBQUUsVUFBRjtBQUNOLHNCQUFNLEVBQUUsS0FBRixDQUFRLFFBQVIsQ0FBaUIsU0FBakIsQ0FBTjthQUhKOzs7O0FBSFEsYUFXUixDQUFFLFdBQUYsR0FYUTs7OztzQ0FjRSxVQUFVO0FBQ3BCLGdCQUFJLElBQUksSUFBSixDQURnQjtBQUVwQixtQkFBTyxFQUFFLE1BQUYsR0FBVyxFQUFFLFVBQUYsQ0FBYSxRQUFiLENBQVgsR0FBb0MsUUFBcEMsQ0FGYTs7Ozs7Ozs7O2tDQVFkO0FBQ04sZ0JBQUksSUFBSSxJQUFKLENBREU7QUFFTixjQUFFLEtBQUYsR0FBVSxPQUFPLEVBQUUsRUFBRixDQUFLLFdBQUwsR0FBbUIsSUFBSSxVQUFKLENBRjlCO0FBR04sY0FBRSxLQUFGLENBQVEsRUFBRSxlQUFGLENBQVIsQ0FITTs7Ozs7Ozs7Ozs7cUNBV0csV0FBVztBQUNwQixnQkFBSSxJQUFJLElBQUosQ0FEZ0I7QUFFcEIsbUJBQU8sRUFBRSxLQUFGLENBQVEsUUFBUixDQUFpQixHQUFqQixDQUFxQixVQUFVLEtBQVYsRUFBaUIsS0FBakIsRUFBd0I7QUFDaEQsdUJBQU87O3NCQUFLLEtBQUssVUFBVSxTQUFTLFlBQVksQ0FBWixHQUFnQixDQUFoQixDQUFULENBQVYsRUFBd0MsS0FBSyxTQUFTLFlBQVksQ0FBWixHQUFnQixDQUFoQixDQUFUO0FBQzlELG1DQUFXLFdBQUcsQ0FBWSxZQUFaLFVBQTZCLFlBQVksWUFBWixDQUFoQyxHQUE4RCxFQUFFLGFBQUYsQ0FBZ0IsS0FBaEIsQ0FBOUQsRUFESjtvQkFFTixLQUZNO2lCQUFQLENBRGdEO2FBQXhCLENBQTVCLENBRm9COzs7O2lDQVVmOzs7QUFDTCxnQkFBSSxJQUFJLElBQUosQ0FEQztBQUVMLG1CQUNJOztrQkFBSyxLQUFJLE1BQUosRUFBVyxXQUFXLGdFQUNuQixZQUFZLE9BQVosR0FBeUIseUNBQ3pCLFlBQVksV0FBWixHQUE2QixFQUFFLEtBQUYsQ0FBUSxRQUFSLGdDQUNoQyxFQUFFLEtBQUYsQ0FBUSxTQUFSLEVBQW9CLENBQUMsQ0FBQyxFQUFFLEtBQUYsQ0FBUSxTQUFSLGVBSEEsQ0FBWCxFQUFoQjtnQkFLQTs7c0JBQUssV0FBYyxZQUFZLElBQVosVUFBcUIsWUFBWSxZQUFaLENBQW5DLEVBQWdFLE9BQU8sRUFBQyxRQUFRLEVBQUUsS0FBRixDQUFRLE1BQVIsRUFBaEIsRUFBckU7b0JBQ0MsRUFBRSxZQUFGLEVBREQ7b0JBRUMsRUFBRSxNQUFGLElBQVksRUFBRSxZQUFGLENBQWUsSUFBZixDQUFaO2lCQVBEO2dCQVNDLEVBQUUsS0FBRixDQUFRLE9BQVIsSUFBbUIsRUFBRSxNQUFGLEdBQVcsQ0FBWCxJQUFnQixvQkFBQyxRQUFELElBQVUsUUFBUSxFQUFFLGFBQUYsQ0FBZ0IsRUFBRSxlQUFGLENBQXhCLEVBQTRDLEtBQUssRUFBRSxLQUFGLENBQVEsUUFBUixDQUFpQixNQUFqQixFQUEzRCxDQUFuQzthQVZMLENBRks7Ozs7V0FyaEJQO0VBQWMsTUFBTSxTQUFOOztBQXVpQnBCLE1BQU0sU0FBTixHQUFrQjtBQUNkLGVBQVcsTUFBTSxTQUFOLENBQWdCLE1BQWhCO0FBQ1gsWUFBUSxNQUFNLFNBQU4sQ0FBZ0IsU0FBaEIsQ0FBMEIsQ0FDOUIsTUFBTSxTQUFOLENBQWdCLE1BQWhCLEVBQ0EsTUFBTSxTQUFOLENBQWdCLE1BQWhCLENBRkksQ0FBUjtBQUlBLFlBQVEsTUFBTSxTQUFOLENBQWdCLE1BQWhCO0FBQ1IsVUFBTSxNQUFNLFNBQU4sQ0FBZ0IsSUFBaEI7QUFDTixVQUFNLE1BQU0sU0FBTixDQUFnQixJQUFoQjtBQUNOLGFBQVMsTUFBTSxTQUFOLENBQWdCLElBQWhCO0FBQ1QsYUFBUyxNQUFNLFNBQU4sQ0FBZ0IsSUFBaEI7QUFDVCxnQkFBWSxNQUFNLFNBQU4sQ0FBZ0IsSUFBaEI7QUFDWixrQkFBYyxNQUFNLFNBQU4sQ0FBZ0IsSUFBaEI7Q0FabEI7O0FBZUEsTUFBTSxZQUFOLEdBQXFCO0FBQ2pCLFlBQVEsTUFBUjtBQUNBLFlBQVEsQ0FBUjtBQUNBLFVBQU0sS0FBTjtBQUNBLFVBQU0sSUFBTjtBQUNBLGFBQVMsS0FBVDtBQUNBLGFBQVMsSUFBVDtBQUNBLGdCQUFZLElBQVo7QUFDQSxrQkFBYyxJQUFkO0NBUko7O0FBV0EsTUFBTSxXQUFOLEdBQWtCLE9BQWxCOztBQUVBLE9BQU8sT0FBUCxHQUFpQixLQUFqQiIsImZpbGUiOiJTbGlkZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuKiBTbGlkZSBDb21wb25lbnQgZm9yIHRpbmdsZVxuKiBAYXV0aG9yIGdub3NhaWosY21cbipcbiogQ29weXJpZ2h0IDIwMTQtMjAxNiwgVGluZ2xlIFRlYW0sIEFsaW53LlxuKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKi9cbmNvbnN0IFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbmNvbnN0IGNsYXNzbmFtZXMgPSByZXF1aXJlKCdjbGFzc25hbWVzJyk7XG5jb25zdCBDb250ZXh0ID0gcmVxdWlyZSgnQGFsaS90aW5nbGUtY29udGV4dCcpO1xuY29uc3QgU2xpZGVOYXYgPSByZXF1aXJlKCcuL1NsaWRlTmF2Jyk7XG5cbmNvbnN0IHByZWZpeENsYXNzID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiBDb250ZXh0LnByZWZpeENsYXNzID8gQ29udGV4dC5wcmVmaXhDbGFzcyhuYW1lKSA6ICd0LScgKyBuYW1lXG59XG5cbmxldCB7XG4gICAgVE9VQ0hfU1RBUlQsXG4gICAgVE9VQ0hfTU9WRSxcbiAgICBUT1VDSF9FTkQsXG4gICAgVE9VQ0hfQ0FOQ0VMLFxuICAgIHN1cHBvcnQzRCxcbiAgICBzdXBwb3J0VG91Y2gsXG4gICAgaXNQQyxcbiAgICBub29wLFxuICAgIFJFU0laRVxufSA9IENvbnRleHQ7XG5cbmxldCB3aW4gPSB3aW5kb3c7XG5sZXQgZG9jID0gZG9jdW1lbnQ7XG5sZXQgT0ZGU0VUID0gJ29mZnNldCc7XG5sZXQgUE9TX01BUCA9IHtcbiAgICAnLTEnOiAnX3ByZXZFbCcsXG4gICAgJzAnOiAnX2N1cnJlbnRFbCcsXG4gICAgJzEnOiAnX25leHRFbCdcbn07XG5cbi8vIOWIm+W7unRyYW5zbGF0ZeWtl+espuS4slxuLy8gVE9ETzogdHJhbnNsYXRlKDAsMCkgdHJhbnNsYXRlWigwKTtcbmxldCBtYWtlVHJhbnNsYXRlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBsZXQgcHJlZml4ID0gc3VwcG9ydDNEID8gJ3RyYW5zbGF0ZTNkKCcgOiAndHJhbnNsYXRlKCc7XG4gICAgbGV0IHN1ZmZpeCA9IHN1cHBvcnQzRCA/ICcsIDApJyA6ICcpJztcbiAgICBsZXQgam9pbiA9ICcsJztcblxuICAgIGZ1bmN0aW9uIHYobikge1xuICAgICAgICBuID0gJycgKyAobiB8fCAwKTtcbiAgICAgICAgbiA9IG4uaW5kZXhPZignJScpID4gLTEgPyBuIDogbiArICdweCc7XG4gICAgICAgIHJldHVybiBuO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICByZXR1cm4gcHJlZml4ICsgdih4KSArIGpvaW4gKyB2KHkpICsgc3VmZml4O1xuICAgIH1cbn0pKCk7XG5cbi8vIOiOt+WPluWFvOWuuVBD5ZKMRGV2aWNl55qEZXZlbnTlr7nosaHnmoRwYWdl5bGe5oCnXG5sZXQgZ2V0Q3Vyc29yUGFnZSA9IHN1cHBvcnRUb3VjaCA/IGZ1bmN0aW9uIChldmVudCwgcGFnZSkge1xuICAgIHJldHVybiBldmVudC5jaGFuZ2VkVG91Y2hlc1swXVtwYWdlXTtcbn0gOiBmdW5jdGlvbiAoZXZlbnQsIHBhZ2UpIHtcbiAgICByZXR1cm4gZXZlbnRbcGFnZV07XG59O1xuXG5jbGFzcyBTbGlkZSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG4gICAgICAgIGxldCB0ID0gdGhpcztcblxuICAgICAgICAvLyDliIfmjaLliqjnlLvnmoTml7bplb9cbiAgICAgICAgdGhpcy5kdXJhdGlvbiA9IDIwMDtcblxuICAgICAgICAvLyDog73lpJ/op6blj5HliIfmjaLnmoTlgY/np7vph49cbiAgICAgICAgdGhpcy5lZmZlY3RpdmVEZWx0YSA9IE1hdGguZmxvb3Iod2luZG93LmlubmVyV2lkdGggLyAxLjgpO1xuXG4gICAgICAgIC8vIOW9k+WBj+enu+mHj+S4jei2s+aXtu+8jOS9v+eUqOmAn+W6puadpeWGs+WumuaYr+WQpuenu+WKqCDljZXkvY3vvJpweC9zXG4gICAgICAgIHRoaXMuc3BlZWQgPSAzMDA7XG5cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGF1dG86IHByb3BzLmF1dG8sXG4gICAgICAgICAgICAvLyDlvZPliY1pdGVt55qE57Si5byV5YC8IOS7pTDlvIDlp4tcbiAgICAgICAgICAgIGluZGV4OiBwcm9wcy5hY3RpdmUsXG4gICAgICAgICAgICBkaXNhYmxlZDogZmFsc2VcbiAgICAgICAgfTtcblxuICAgICAgICAvLyDlvZPlsY/luZXml4vovaznmoTml7blgJnvvIzkv67mraPluIPlsYBcbiAgICAgICAgd2luLmFkZEV2ZW50TGlzdGVuZXIoUkVTSVpFLCB0LCBmYWxzZSk7XG4gICAgfVxuXG4gICAgY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgICAgICBsZXQgdCA9IHRoaXM7XG4gICAgICAgIHQuX2dldExlbmd0aCgpO1xuICAgIH1cblxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICBsZXQgdCA9IHRoaXM7XG5cbiAgICAgICAgdC5lbCA9IHQucmVmcy5yb290O1xuXG4gICAgICAgIC8vIOehruWumuWuueWZqOWuveW6plxuICAgICAgICB0LndpZHRoID0gaXNQQyA/IHQuZWwuY2xpZW50V2lkdGggOiB3aW4uaW5uZXJXaWR0aDtcblxuICAgICAgICB0Ll9zZXRDb250ZXh0KCk7XG4gICAgfVxuXG4gICAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgICAgICBsZXQgdCA9IHRoaXM7XG4gICAgICAgIGxldCBvbGRDaGlsZHJlbkxlbmd0aCA9IHByZXZQcm9wcy5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgIGxldCBuZXdDaGlsZHJlbkxlbmd0aCA9IHRoaXMucHJvcHMuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICBpZiAobmV3Q2hpbGRyZW5MZW5ndGggIT0gb2xkQ2hpbGRyZW5MZW5ndGgpIHtcbiAgICAgICAgICAgIHQuX2dldExlbmd0aCgpO1xuICAgICAgICAgICAgdC5fc2V0Q29udGV4dChwcmV2UHJvcHMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIGxldCB0ID0gdGhpcztcbiAgICAgICAgaWYgKHQubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdC5lbC5yZW1vdmVFdmVudExpc3RlbmVyKFRPVUNIX1NUQVJULCB0LCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoUkVTSVpFLCB0LCBmYWxzZSk7XG4gICAgICAgIGNsZWFyVGltZW91dCh0Ll9hdXRvU2xpZGVUaW1lcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiDojrflj5Ygc2xpZGUg5YiX6KGo55qE55yf5q2j6ZW/5bqm77yM5Li76KaB5piv6ICD6JmRIGNoaWxkcmVuXG4gICAgKiDplb/luqbmmK8gMSDlkowgMiDnmoTmg4XlhrXkuItcbiAgICAqL1xuICAgIF9nZXRMZW5ndGgoKSB7XG4gICAgICAgIGxldCB0ID0gdGhpcztcbiAgICAgICAgbGV0IG9yaWdpbkxlbmd0aCA9IFJlYWN0LkNoaWxkcmVuLmNvdW50KHQucHJvcHMuY2hpbGRyZW4pO1xuXG4gICAgICAgIC8vIFRPRE86IGNoZWNrXG4gICAgICAgIGlmIChvcmlnaW5MZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHQuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIGRpc2FibGVkOiB0cnVlXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaXRlbeeahOmVv+W6pue7j+WkhOeQhuWQjuS4jeWtmOWcqOS4ujLnmoTmg4XlhrVcbiAgICAgICAgZWxzZSBpZiAob3JpZ2luTGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICB0Ll9kdW1teSA9IHRydWU7XG4gICAgICAgICAgICB0Ll9yZWFsSW5kZXggPSB7XG4gICAgICAgICAgICAgICAgJzAnOiAwLFxuICAgICAgICAgICAgICAgICcxJzogMSxcbiAgICAgICAgICAgICAgICAnMic6IDAsXG4gICAgICAgICAgICAgICAgJzMnOiAxXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8g5aSE55CG5Lul5ZCO55qE6ZW/5bqm77yM5Y2zaXRlbeeahOS4quaVsFxuICAgICAgICB0Lmxlbmd0aCA9IHQuX2R1bW15ID8gNCA6IG9yaWdpbkxlbmd0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIOagueaNriBzbGlkZSDliJfooajplb/luqborr7nva7mraPnoa7nmoTlhoXpg6jlj5jph49cbiAgICAqXG4gICAgKi9cbiAgICBfc2V0Q29udGV4dChwcmV2UHJvcHMpIHtcbiAgICAgICAgbGV0IHQgPSB0aGlzO1xuXG4gICAgICAgIC8vIOeUseS6juWtkOWFg+e0oOaVsOmHj+acieWPmOWMlu+8jOWFiOino+e7keS4juaVsOmHj+ebuOWFs+eahOebkeWQrO+8jOWGjeagueaNruaVsOmHj+mHjeaWsOe7keWumuOAglxuICAgICAgICB0LmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoVE9VQ0hfU1RBUlQsIHQsIGZhbHNlKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHQuX2F1dG9TbGlkZVRpbWVyKTtcblxuICAgICAgICAvLyDoh7PlsJHmnIky5bygc2xpZGXml7bvvIzmiY3liJ3lp4vljJbkuovku7ZcbiAgICAgICAgaWYgKHQubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdC5lbC5hZGRFdmVudExpc3RlbmVyKFRPVUNIX1NUQVJULCB0LCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0LmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICB0LnByb3BzLm9uU2xpZGVDbGljayh7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiAwLFxuICAgICAgICAgICAgICAgICAgICBpdGVtOiB0Ll9jdXJyZW50RWwsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHQucHJvcHMuY2hpbGRyZW5bMF1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIOWJjeS4gOS4qu+8jOW9k+WJjeeahO+8jOWQjuS4gOS4qml0ZW3nmoRlbGVtZW505byV55SoXG4gICAgICAgIHQuX3ByZXZFbCA9IG51bGw7XG4gICAgICAgIHQuX2N1cnJlbnRFbCA9IG51bGw7XG4gICAgICAgIHQuX25leHRFbCA9IG51bGw7XG5cbiAgICAgICAgdC5fZGVsdGFYID0gMDtcbiAgICAgICAgdC5fbWluSW5kZXggPSAwO1xuICAgICAgICB0Ll9tYXhJbmRleCA9IHQubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKCFwcmV2UHJvcHMpIHtcbiAgICAgICAgICAgIHQucHJvcHMub25Nb3VudCh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHQuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIGluZGV4OiB0LnByb3BzLmluZGV4XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodC5sZW5ndGggIT0gMCkge1xuICAgICAgICAgICAgdC5fZ290byh0LnN0YXRlLmluZGV4LCB0cnVlKTtcbiAgICAgICAgICAgIHQuX2F1dG9TbGlkZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2F1dG9TbGlkZSgpIHtcbiAgICAgICAgbGV0IHQgPSB0aGlzO1xuICAgICAgICBpZiAoIXQuc3RhdGUuYXV0bykgcmV0dXJuO1xuICAgICAgICB0Ll9hdXRvU2xpZGVUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdC5nb05leHQoKTtcbiAgICAgICAgICAgIHQuX2F1dG9TbGlkZSgpO1xuICAgICAgICB9LCA0MDAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCDnm67moIfkvY3nva7nmoTntKLlvJXlgLxcbiAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY2FsbEZyb21EaWRNb3VudCDmmK/lkKbmmK/lnKggY29tcG9uZW50RGlkTW91bnQg5Lit6KKr6LCD55So55qEXG4gICAgKi9cbiAgICBfZ290byhwb3NJbmRleCwgY2FsbEZyb21EaWRNb3VudCkge1xuICAgICAgICBsZXQgdCA9IHRoaXM7XG4gICAgICAgIGNhbGxGcm9tRGlkTW91bnQgPSAhIWNhbGxGcm9tRGlkTW91bnQ7XG5cbiAgICAgICAgaWYgKHQubGVuZ3RoID09PSAxIHx8IGNhbGxGcm9tRGlkTW91bnQpIHtcbiAgICAgICAgICAgIC8vIGBfZ2V0SXRlbVJlYWR5YCDmlrnms5XooqvosIPnlKjkuYvliY3vvIzpnIDopoHlhYjmm7TmlrAgYGN1cnJlbnRQb3NJbmRleGAg55qE5YC8XG4gICAgICAgICAgICB0LmN1cnJlbnRQb3NJbmRleCA9IHBvc0luZGV4O1xuICAgICAgICAgICAgdC5fZ2V0SXRlbVJlYWR5KDApO1xuXG4gICAgICAgICAgICBpZiAodC5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgdC5fZ2V0SXRlbVJlYWR5KDEpO1xuICAgICAgICAgICAgICAgIHQuX2dldEl0ZW1SZWFkeSgtMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHQuX3NsaWRlRW5kKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWNhbGxGcm9tRGlkTW91bnQpIHtcblxuICAgICAgICAgICAgLy8g6YCa6L+HZ29OZXh0L2dvUHJlduiwg+eUqOeahF9nb3Rv77yM5LiA55u05pyJ5pa55ZCRKF9kaXIp5YC8IOWQkeW3pjotMSAvIOWQkeWPszoxXG4gICAgICAgICAgICBpZiAodC5fZGlyKSB7XG4gICAgICAgICAgICAgICAgdC5fZ2V0SXRlbVVucmVhZHkodC5fZGlyID09PSAxID8gdC5fbmV4dEVsIDogdC5fcHJldkVsKTtcbiAgICAgICAgICAgICAgICB0Ll9tb3ZlSXRlbSh0Ll9jdXJyZW50RWwsIHQuX2Rpcik7XG4gICAgICAgICAgICAgICAgdC5fbW92ZUl0ZW0odC5fZGlyID09PSAxID8gdC5fcHJldkVsIDogdC5fbmV4dEVsLCB0Ll9kaXIpO1xuXG4gICAgICAgICAgICAgICAgLy8gYF9nZXRJdGVtUmVhZHlg5pa55rOV6KKr6LCD55So5LmL5YmN77yM6ZyA6KaB5YWI5pu05pawYGN1cnJlbnRQb3NJbmRleGDnmoTlgLxcbiAgICAgICAgICAgICAgICB0LmN1cnJlbnRQb3NJbmRleCA9IHBvc0luZGV4O1xuICAgICAgICAgICAgICAgIHQuX2dldEl0ZW1SZWFkeSh0Ll9kaXIgKiAtMSk7XG5cbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdC5fc2xpZGVFbmQoKTtcbiAgICAgICAgICAgICAgICB9LCB0LmR1cmF0aW9uKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8g5b2S5L2N55qE5oOF5Ya177ya56e75Yqo6Led56a75bCP5LqO5pyJ5pWI6Led56a75pe2XG4gICAgICAgICAgICBlbHNlIGlmIChwb3NJbmRleCA9PT0gdC5jdXJyZW50UG9zSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAvLyDlvZLkvY3lvZPliY1pdGVtXG4gICAgICAgICAgICAgICAgdC5fbW92ZUl0ZW0odC5fY3VycmVudEVsLCAwKTtcbiAgICAgICAgICAgICAgICAvLyDlvZLkvY3ov5vlhaXlsY/luZXnmoTlj6bkuIDkuKppdGVtXG4gICAgICAgICAgICAgICAgLy8g6K+05piOOuS7u+aEj+S4gOS4quaXtumXtOeCuSzlh7rnjrDlnKjlsY/luZXlhoXnmoRpdGVt5pWw6YeP5pyA5aSa5Li6MuS4qizopoHkuYjlt6bovrks6KaB5LmI5Y+z6L65LOWPluWGs+S6juenu+WKqOaWueWQkVxuICAgICAgICAgICAgICAgIGlmICh0Ll9tb3ZlQmFjaykge1xuICAgICAgICAgICAgICAgICAgICB0Ll9tb3ZlSXRlbSh0Ll9tb3ZlQmFjaywgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIOW9k3Jlc2l6ZeaXtlxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0Ll9tb3ZlSXRlbSh0Ll9wcmV2RWwsIDApO1xuICAgICAgICAgICAgICAgICAgICB0Ll9tb3ZlSXRlbSh0Ll9uZXh0RWwsIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHQuX21vdmVCYWNrID0gbnVsbDtcbiAgICAgICAgdC5fZGlyID0gbnVsbDtcbiAgICB9XG5cbiAgICBnb05leHQoKSB7XG4gICAgICAgIGxldCB0ID0gdGhpcztcbiAgICAgICAgLy8g5pa55ZCR5piv5ZCR5bemKC0xKe+8jOimgeWxleeOsOeahOaYr+WQjuS4gOW8oCgxKVxuICAgICAgICB0Ll9kaXIgPSAtMTtcbiAgICAgICAgdC5fZ290byh0Ll9nZXRQb3NJbmRleCgxKSk7XG4gICAgfVxuXG4gICAgZ29QcmV2KCkge1xuICAgICAgICBsZXQgdCA9IHRoaXM7XG4gICAgICAgIC8vIOaWueWQkeaYr+WQkeWPsygxKe+8jOimgeWxleeOsOeahOaYr+WJjeS4gOW8oCgtMSlcbiAgICAgICAgdC5fZGlyID0gMTtcbiAgICAgICAgdC5fZ290byh0Ll9nZXRQb3NJbmRleCgtMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICog56e75YqoaXRlbeWIsOaWsOeahOS9jee9rlxuICAgICogQHBhcmFtIHtlbGVtZW50fSBpdGVtXG4gICAgKiBAcGFyYW0ge251bWJlcn0gZGlyIOenu+WKqOeahOaWueWQkSAtMTrlkJHlt6bnp7vliqggLyAxOuWQkeWPs+enu+WKqCAvIDA656e75Yqo5Yiw5Y6f5L2NXG4gICAgKi9cbiAgICBfbW92ZUl0ZW0oaXRlbSwgZGlyKSB7XG4gICAgICAgIGxldCB0ID0gdGhpcztcbiAgICAgICAgaXRlbS5zdHlsZS53ZWJraXRUcmFuc2l0aW9uRHVyYXRpb24gPSB0LmR1cmF0aW9uICsgJ21zJztcblxuICAgICAgICBsZXQgbmV3T2Zmc2V0ID0gK2l0ZW0uZ2V0QXR0cmlidXRlKE9GRlNFVCkgKyBkaXI7XG5cbiAgICAgICAgdC5fc2V0SXRlbVgoaXRlbSwgdC5fZ2V0UG9zWChuZXdPZmZzZXQpKTtcblxuICAgICAgICAvLyDlpoLmnpzov5vooYzkuobliIfmjaLooYzkuLrvvIzljbNkaXLkuLotMeaIljFcbiAgICAgICAgaWYgKGRpcikge1xuICAgICAgICAgICAgaXRlbS5zZXRBdHRyaWJ1dGUoT0ZGU0VULCBuZXdPZmZzZXQpO1xuICAgICAgICAgICAgdFtQT1NfTUFQW25ld09mZnNldF1dID0gaXRlbTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICog5qC55o2u5oyH5a6a55qE5YGP56e76YeP77yM5om+5Yiw5a+55bqU55qEaXRlbe+8jOWwhuWFtuWIh+aNouWIsOWPr+enu+WKqOeKtuaAgVxuICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCAtMTrliY3kuIDkuKrkvY3nva4gLyAwOuW9k+WJjeS9jee9riAvIDE6IOWQjuS4gOS4quS9jee9rlxuICAgICogQG5vdGUg5Lu75L2V5pe25Yi777yM5Y+v56e75Yqo54q25oCB55qEaXRlbeaVsOmHj+WPquacieS4ieS4qlxuICAgICogQG5vdGUg6K+l5pa55rOV5L6d6LWWYGN1cnJlbnRQb3NJbmRleGDlkoxgb2Zmc2V0YOafpeaJvuebruagh2BpdGVtYO+8jFxuICAgICogICAgICAg6ICMYF9nZXRJdGVtVW5yZWFkeWDmlrnms5Xnm7TmjqXnu5nlrprkuoZgaXRlbWDvvIzkuI3pnIDopoHkvp3otZZgY3VycmVudFBvc0luZGV4YOWSjGBvZmZzZXRgXG4gICAgKi9cbiAgICBfZ2V0SXRlbVJlYWR5KG9mZnNldCkge1xuICAgICAgICBsZXQgdCA9IHRoaXM7XG4gICAgICAgIGxldCB0YXJnZXRQb3NJbmRleCA9IHQuX2dldFBvc0luZGV4KG9mZnNldCk7XG4gICAgICAgIGxldCBpdGVtID0gdC5yZWZzWydpdGVtJyArIHRhcmdldFBvc0luZGV4XTtcbiAgICAgICAgaXRlbS5jbGFzc0xpc3QuYWRkKCdyZWFkeScpO1xuICAgICAgICBpdGVtLnNldEF0dHJpYnV0ZShPRkZTRVQsIG9mZnNldCk7XG4gICAgICAgIGl0ZW0uc3R5bGUud2Via2l0VHJhbnNmb3JtID0gbWFrZVRyYW5zbGF0ZSh0Ll9nZXRQb3NYKG9mZnNldCkpO1xuICAgICAgICB0W1BPU19NQVBbb2Zmc2V0XV0gPSBpdGVtO1xuICAgIH1cblxuICAgIC8qKlxuICAgICog5bCG5oyH5a6a55qEaXRlbeWIh+aNouWIsOS4jeWPr+enu+WKqOeKtuaAge+8jOWNs+S4jeWPguS4juWIh+aNouihjOS4uuOAglxuICAgICogQHBhcmFtIHtlbGVtZW50fSBpdGVtIOimgeaUueWPmOeKtuaAgeeahGl0ZW1cbiAgICAqIEBub3RlIOi/meS4quWHveaVsOiZveeEtuWQq+S5ieS4iuWSjF9zZXRJdGVtUmVhZHnlr7nlupTvvIzkvYblj4LmlbDnm7TmjqXlj6rnlKhpdGVt77yMXG4gICAgKiAg5piv5Ye65LqO5oCn6IO96ICD6JmR77yM5Zug5Li66LCD55So6K+l5Ye95pWw55qE5pe25YCZ77yM6YO95piv5piO56Gu55+l6YGT55uu5qCHaXRlbeeahOOAglxuICAgICovXG4gICAgX2dldEl0ZW1VbnJlYWR5KGl0ZW0pIHtcbiAgICAgICAgbGV0IHQgPSB0aGlzO1xuICAgICAgICBpdGVtLmNsYXNzTGlzdC5yZW1vdmUoJ3JlYWR5Jyk7XG4gICAgICAgIGl0ZW0ucmVtb3ZlQXR0cmlidXRlKE9GRlNFVCk7XG4gICAgICAgIGl0ZW0uc3R5bGUud2Via2l0VHJhbnNpdGlvbkR1cmF0aW9uID0gJzAnO1xuICAgICAgICBpdGVtLnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9ICdub25lJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIOiOt+WPluaMh+WumueahG9mZnNldOaJgOWvueW6lOeahFjlnZDmoIflgLwoMOeCueWcqOW9k+WJjWl0ZW3nmoTlt6bovrnnvJgpXG4gICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IC0xOuWJjeS4gOS4quS9jee9riAvIDA65b2T5YmN5L2N572uIC8gMTog5ZCO5LiA5Liq5L2N572uXG4gICAgKi9cbiAgICBfZ2V0UG9zWChvZmZzZXQpIHtcbiAgICAgICAgbGV0IHQgPSB0aGlzO1xuICAgICAgICByZXR1cm4gb2Zmc2V0ID09PSAtMSA/IC10LndpZHRoIDogb2Zmc2V0ID09PSAxID8gdC53aWR0aCA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKlxuICAgICovXG4gICAgX3NldEl0ZW1YKGl0ZW0sIHgpIHtcbiAgICAgICAgdGhpc1tQT1NfTUFQW2l0ZW0uZ2V0QXR0cmlidXRlKE9GRlNFVCldICsgJ1gnXSA9IHg7XG4gICAgICAgIGl0ZW0uc3R5bGUud2Via2l0VHJhbnNmb3JtID0gbWFrZVRyYW5zbGF0ZSh4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIOiOt+WPluWJjeS4gOS4quaIluWQjuS4gOS4quS9jee9rueahOe0ouW8leWAvO+8jOebuOWvueWAvOaYr2N1cnJlbnRQb3NJbmRleFxuICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCAtMTrlj5bliY3kuIDkuKrkvY3nva4gLyAwOuWPluW9k+WJjeS9jee9riAvIDE6IOWPluWQjuS4gOS4quS9jee9rlxuICAgICovXG4gICAgX2dldFBvc0luZGV4KG9mZnNldCkge1xuICAgICAgICBsZXQgdCA9IHRoaXMsIGluZGV4O1xuICAgICAgICBpZiAob2Zmc2V0ID09PSAtMSkge1xuICAgICAgICAgICAgaW5kZXggPSB0LmN1cnJlbnRQb3NJbmRleCA9PT0gdC5fbWluSW5kZXggPyB0Ll9tYXhJbmRleCA6IHQuY3VycmVudFBvc0luZGV4IC0gMTtcbiAgICAgICAgfSBlbHNlIGlmIChvZmZzZXQgPT09IDEpIHtcbiAgICAgICAgICAgIGluZGV4ID0gdC5jdXJyZW50UG9zSW5kZXggPT09IHQuX21heEluZGV4ID8gdC5fbWluSW5kZXggOiB0LmN1cnJlbnRQb3NJbmRleCArIDE7XG4gICAgICAgIH0gZWxzZSBpZiAob2Zmc2V0ID09PSAwKSB7XG4gICAgICAgICAgICBpbmRleCA9IHQuY3VycmVudFBvc0luZGV4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlcnJvciBvZmZzZXQnKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG5cbiAgICBoYW5kbGVFdmVudChlKSB7XG4gICAgICAgIGxldCB0ID0gdGhpcztcbiAgICAgICAgc3dpdGNoIChlLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgVE9VQ0hfU1RBUlQ6XG4gICAgICAgICAgICB0Ll90b3VjaFN0YXJ0KGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFRPVUNIX01PVkU6XG4gICAgICAgICAgICB0Ll90b3VjaE1vdmUoZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgVE9VQ0hfRU5EOlxuICAgICAgICAgICAgdC5fdG91Y2hFbmQoZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgVE9VQ0hfQ0FOQ0VMOlxuICAgICAgICAgICAgdC5fdG91Y2hFbmQoZSk7XG4gICAgICAgICAgICBjYXNlIFJFU0laRTpcbiAgICAgICAgICAgIHQuX3Jlc2l6ZShlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3RvdWNoU3RhcnQoZSkge1xuICAgICAgICAvLyDlj6rlk43lupTljZXmjIfmk43kvZxcbiAgICAgICAgaWYgKHN1cHBvcnRUb3VjaCAmJiBlLnRvdWNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHQgPSB0aGlzO1xuXG4gICAgICAgIGNsZWFyVGltZW91dCh0Ll9hdXRvU2xpZGVUaW1lcik7XG5cbiAgICAgICAgLy8g5oGi5aSN5YiwMCDmi5bmi73ov4fnqIvkuK3lv6vpgJ/lk43lupTnp7vliqjot53nprtcbiAgICAgICAgdC5fcHJldkVsLnN0eWxlLndlYmtpdFRyYW5zaXRpb25EdXJhdGlvbiA9ICcwbXMnO1xuICAgICAgICB0Ll9jdXJyZW50RWwuc3R5bGUud2Via2l0VHJhbnNpdGlvbkR1cmF0aW9uID0gJzBtcyc7XG4gICAgICAgIHQuX25leHRFbC5zdHlsZS53ZWJraXRUcmFuc2l0aW9uRHVyYXRpb24gPSAnMG1zJztcblxuICAgICAgICAvLyDnp7vliqjliJ3lp4vlgLxcbiAgICAgICAgdC5fcHJldkVsWCA9IHQuX2dldFBvc1goLTEpO1xuICAgICAgICB0Ll9jdXJyZW50RWxYID0gdC5fZ2V0UG9zWCgwKTtcbiAgICAgICAgdC5fbmV4dEVsWCA9IHQuX2dldFBvc1goMSk7XG5cbiAgICAgICAgLy8g5rWP6KeI5Zmo6buY6K6k5rua5YqoXG4gICAgICAgIHQuYnJvd3NlclNjcm9sbGluZyA9IGZhbHNlO1xuXG4gICAgICAgIC8vIOaYr+WQpuaYr+WIh+aNoueKtuaAgSDmraTml7blv73nlaXmtY/op4jlmajpu5jorqTnmoTmu5rliqjooYzkuLpcbiAgICAgICAgdC5zbGlkaW5nID0gZmFsc2U7XG5cbiAgICAgICAgdC5zdGFydFBhZ2VYID0gZ2V0Q3Vyc29yUGFnZShlLCAncGFnZVgnKTtcbiAgICAgICAgdC5zdGFydFBhZ2VZID0gZ2V0Q3Vyc29yUGFnZShlLCAncGFnZVknKTtcbiAgICAgICAgdC5iYXNlUGFnZVggPSB0LnN0YXJ0UGFnZVg7XG4gICAgICAgIHQuc3RhcnRUaW1lID0gZS50aW1lU3RhbXA7XG5cbiAgICAgICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoVE9VQ0hfTU9WRSwgdCwgZmFsc2UpO1xuICAgICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcihUT1VDSF9FTkQsIHQsIGZhbHNlKTtcbiAgICB9XG5cbiAgICBfdG91Y2hNb3ZlKGUpIHtcbiAgICAgICAgLy8g5Y+q5ZON5bqU5Y2V5oyH5pON5L2cXG4gICAgICAgIGlmIChzdXBwb3J0VG91Y2ggJiYgZS50b3VjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB0ID0gdGhpcztcblxuICAgICAgICAvLyDlpoLmnpzmtY/op4jlmajpu5jorqTmu5rliqjooYzkuLrlt7Looqvop6blj5HvvIzliJnkuI3miafooYxTbGlkZXLnmoTmu5rliqhcbiAgICAgICAgaWYgKHQuYnJvd3NlclNjcm9sbGluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHBhZ2VYID0gZ2V0Q3Vyc29yUGFnZShlLCAncGFnZVgnKSxcbiAgICAgICAgcGFnZVkgPSBnZXRDdXJzb3JQYWdlKGUsICdwYWdlWScpLFxuICAgICAgICBkaXN0WCxcbiAgICAgICAgbmV3UHJldlgsXG4gICAgICAgIG5ld0N1cnJlbnRYLFxuICAgICAgICBuZXdOZXh0WCxcbiAgICAgICAgZGVsdGFZO1xuXG4gICAgICAgIHQuZGVsdGFYID0gcGFnZVggLSB0LnN0YXJ0UGFnZVg7XG5cbiAgICAgICAgLy8g5aaC5p6cc2xpZGXlvIDlp4vmu5rliqhcbiAgICAgICAgaWYgKHQuc2xpZGluZykge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICAgICAgLy8g5Lu75oSP5pe25Yi755qE5L2N56e75YC8XG4gICAgICAgICAgICBkaXN0WCA9IHBhZ2VYIC0gdC5iYXNlUGFnZVg7XG5cbiAgICAgICAgICAgIC8vIOW9k+S4jeaYr+W+queOr+aooeW8j+eahOaXtuWAme+8jOesrOS4gOW8oOWSjOacgOWQjuS4gOW8oOa3u+WKoOeymOaAp1xuICAgICAgICAgICAgaWYgKHQucHJvcHMubG9vcCA9PT0gZmFsc2UgJiYgKChkaXN0WCA+PSAwICYmIHQuY3VycmVudFBvc0luZGV4ID09PSB0Ll9taW5JbmRleCkgfHwgKGRpc3RYIDwgMCAmJiB0LmN1cnJlbnRQb3NJbmRleCA9PT0gdC5fbWF4SW5kZXgpIHx8IChkaXN0WCA8IDAgJiYgdC5fZHVtbXkgJiYgdC5jdXJyZW50UG9zSW5kZXggPT09IDEpKSkge1xuICAgICAgICAgICAgICAgIGRpc3RYID0gZGlzdFggLSBkaXN0WCAvIDEuMztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8g5L2N56e75ZCO55qEWOWdkOagh1xuICAgICAgICAgICAgbmV3UHJldlggPSB0Ll9wcmV2RWxYICsgZGlzdFg7XG4gICAgICAgICAgICBuZXdDdXJyZW50WCA9IHQuX2N1cnJlbnRFbFggKyBkaXN0WDtcbiAgICAgICAgICAgIG5ld05leHRYID0gdC5fbmV4dEVsWCArIGRpc3RYO1xuXG4gICAgICAgICAgICAvLyDmm7TmlrBET03kvY3nva5cbiAgICAgICAgICAgIHQuX3NldEl0ZW1YKHQuX3ByZXZFbCwgbmV3UHJldlgpO1xuICAgICAgICAgICAgdC5fc2V0SXRlbVgodC5fY3VycmVudEVsLCBuZXdDdXJyZW50WCk7XG4gICAgICAgICAgICB0Ll9zZXRJdGVtWCh0Ll9uZXh0RWwsIG5ld05leHRYKTtcblxuICAgICAgICAgICAgaWYgKHQuZGVsdGFYID49IDApIHtcbiAgICAgICAgICAgICAgICB0Ll9tb3ZlQmFjayA9IHQuX3ByZXZFbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdC5fbW92ZUJhY2sgPSB0Ll9uZXh0RWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWx0YVkgPSBwYWdlWSAtIHQuc3RhcnRQYWdlWTtcblxuICAgICAgICAgICAgLy8g5aaC5p6cWOi9tOeahOenu+WKqOi3neemu+WFiOi+vuWIsDVweO+8jOWImeaJp+ihjFNsaWRlcueahOa7muWKqFxuICAgICAgICAgICAgLy8g5aaC5p6cWei9tOeahOenu+WKqOi3neemu+WFiOi+vuWIsDVweO+8jOWImeaJp+ihjOa1j+iniOWZqOm7mOiupOeahOmhtemdoua7muWKqFxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHQuZGVsdGFYKSA+IDUpIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICB0LnNsaWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyhkZWx0YVkpID4gNSkge1xuICAgICAgICAgICAgICAgIHQuYnJvd3NlclNjcm9sbGluZyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0LmJhc2VQYWdlWCA9IHBhZ2VYO1xuICAgIH1cblxuICAgIF90b3VjaEVuZChlKSB7XG4gICAgICAgIC8vIOWPquWTjeW6lOWNleaMh+aTjeS9nFxuICAgICAgICBpZiAoc3VwcG9ydFRvdWNoICYmIGUudG91Y2hlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgdCA9IHRoaXM7XG5cbiAgICAgICAgLy8g5aaC5p6c5rWP6KeI5Zmo6buY6K6k5rua5Yqo6KGM5Li65bey6KKr6Kem5Y+R77yM5YiZ5LiN5omn6KGMU2xpZGVy55qE5rua5YqoXG4gICAgICAgIGlmICh0LmJyb3dzZXJTY3JvbGxpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHQuYnJvd3NlclNjcm9sbGluZyA9IGZhbHNlO1xuXG4gICAgICAgIGxldCBlbmRUaW1lID0gZS50aW1lU3RhbXA7XG4gICAgICAgIGxldCBzcGVlZCA9IE1hdGguZmxvb3IodC5kZWx0YVgvKHQuc3RhcnRUaW1lIC0gZW5kVGltZSkgKiAxMDAwKTtcblxuICAgICAgICAvLyDlkJHlj7Pmu5HliqhcbiAgICAgICAgaWYgKHQuZGVsdGFYID4gdC5lZmZlY3RpdmVEZWx0YSB8fCBzcGVlZCA8IC10LnNwZWVkKSB7XG4gICAgICAgICAgICBpZiAodC5wcm9wcy5sb29wID09PSBmYWxzZSAmJiB0LmN1cnJlbnRQb3NJbmRleCA9PT0gdC5fbWluSW5kZXgpIHtcbiAgICAgICAgICAgICAgICB0Ll9nb3RvKHQuY3VycmVudFBvc0luZGV4KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdC5nb1ByZXYoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIOWQkeW3pua7keWKqFxuICAgICAgICBlbHNlIGlmICh0LmRlbHRhWCA8IC10LmVmZmVjdGl2ZURlbHRhIHx8IHNwZWVkID4gdC5zcGVlZCkge1xuICAgICAgICAgICAgaWYgKHQucHJvcHMubG9vcCA9PT0gZmFsc2UgJiYgKHQuY3VycmVudFBvc0luZGV4ID09PSB0Ll9tYXhJbmRleCB8fCAodC5fZHVtbXkgJiYgdC5jdXJyZW50UG9zSW5kZXggPT09IDEpKSkge1xuICAgICAgICAgICAgICAgIHQuX2dvdG8odC5jdXJyZW50UG9zSW5kZXgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0LmdvTmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8g54K55Ye7XG4gICAgICAgIGVsc2UgaWYgKGVuZFRpbWUgLSB0LnN0YXJ0VGltZSA8IDUwMCAmJiBNYXRoLmFicyh0LmRlbHRhWD4+MCkgPCA1KSB7XG4gICAgICAgICAgICB0Ll9zbGlkZUNsaWNrKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyDkv53mjIHljp/mnInkvY3nva5cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0Ll9nb3RvKHQuY3VycmVudFBvc0luZGV4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHQuZGVsdGFYID0gMDtcblxuICAgICAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcihUT1VDSF9NT1ZFLCB0LCBmYWxzZSk7XG4gICAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKFRPVUNIX0VORCwgdCwgZmFsc2UpO1xuXG4gICAgICAgIHQuX2F1dG9TbGlkZSgpO1xuICAgIH1cblxuICAgIF9zbGlkZUNsaWNrKCkge1xuICAgICAgICBsZXQgdCA9IHRoaXM7XG4gICAgICAgIGxldCByZWFsSW5kZXggPSB0Ll9nZXRSZWFsSW5kZXgodC5jdXJyZW50UG9zSW5kZXgpO1xuICAgICAgICB0LnByb3BzLm9uU2xpZGVDbGljayh7XG4gICAgICAgICAgICBpbmRleDogcmVhbEluZGV4LFxuICAgICAgICAgICAgaXRlbTogdC5fY3VycmVudEVsLFxuICAgICAgICAgICAgZGF0YTogdC5wcm9wcy5jaGlsZHJlbltyZWFsSW5kZXhdXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIF9zbGlkZUVuZCgpIHtcbiAgICAgICAgbGV0IHQgPSB0aGlzO1xuICAgICAgICBsZXQgcmVhbEluZGV4ID0gdC5fZ2V0UmVhbEluZGV4KHQuY3VycmVudFBvc0luZGV4KTtcbiAgICAgICAgdC5wcm9wcy5vblNsaWRlRW5kKHtcbiAgICAgICAgICAgIGluZGV4OiByZWFsSW5kZXgsXG4gICAgICAgICAgICBpdGVtOiB0Ll9jdXJyZW50RWwsXG4gICAgICAgICAgICBkYXRhOiB0LnByb3BzLmNoaWxkcmVuW3JlYWxJbmRleF1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvY29tcG9uZW50LWFwaS5odG1sI2ZvcmNldXBkYXRlXG4gICAgICAgIC8vIOmAmuW4uOaDheWGteS4i+aIkeS7rOS4jeS9v+eUqCBmb3JjZWNVcGRhdGXvvIzkvYbmiJHku6zpnIDopoEgc2xpZGUg6L+H56iL5Lit55qE5Lit6Ze05Y+Y6YePXG4gICAgICAgIC8vIOiAjOmdnuacgOe7iCBzdGF0ZSDljrvop6blj5Hmj5Lku7bnmoTmm7TmlrDvvIzlm6DmraTov5nph4zmiJHku6znlKjliLDkuoYgZm9yY2VVcGRhdGXjgIJcbiAgICAgICAgdC5mb3JjZVVwZGF0ZSgpO1xuICAgIH1cblxuICAgIF9nZXRSZWFsSW5kZXgocG9zSW5kZXgpIHtcbiAgICAgICAgbGV0IHQgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdC5fZHVtbXkgPyB0Ll9yZWFsSW5kZXhbcG9zSW5kZXhdIDogcG9zSW5kZXg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiDlvZPlsY/luZXml4vovazml7bvvIzmm7TmlrDln7rmnKzmlbDmja4gJiYg5YaN5qyh5a6a5L2NXG4gICAgKi9cbiAgICBfcmVzaXplKCkge1xuICAgICAgICBsZXQgdCA9IHRoaXM7XG4gICAgICAgIHQud2lkdGggPSBpc1BDID8gdC5lbC5jbGllbnRXaWR0aCA6IHdpbi5pbm5lcldpZHRoO1xuICAgICAgICB0Ll9nb3RvKHQuY3VycmVudFBvc0luZGV4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIOa4suafk2l0ZW1zIOW9k2l0ZW3mlbDph4/kuLoy5pe277yM6K+l5pa55rOV5Lya6KKr6LCD55So5Lik5qyh77yM56ys5LqM5qyh5Ye95pWw5Li6dHJ1Ze+8jOS7peWunueOsOW+queOr+i9ruaSrVxuICAgICogQHBhcmFtIHtib29sZWFufSBkdW1teU1vZGUg5piv5ZCm5piv5Zyo5riy5p+T6KGl5L2N55qEaXRlbe+8jFxuICAgICogQG5vdGUg5Y+q5pyJ5b2TYHByb3BzLmNoaWxkcmVuYOeahOmVv+W6puS4ujLml7bvvIzmiY3pnIDopoHov5vooYzooaXkvY1cbiAgICAqL1xuICAgIF9yZW5kZXJJdGVtcyhkdW1teU1vZGUpIHtcbiAgICAgICAgbGV0IHQgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdC5wcm9wcy5jaGlsZHJlbi5tYXAoZnVuY3Rpb24gKENoaWxkLCBpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIDxkaXYgcmVmPXtcIml0ZW1cIiArIChpbmRleCArIChkdW1teU1vZGUgPyAyIDogMCkpfSBrZXk9e2luZGV4ICsgKGR1bW15TW9kZSA/IDIgOiAwKX1cbiAgICAgICAgICAgIGNsYXNzTmFtZT17YCR7cHJlZml4Q2xhc3MoJ3NsaWRlLWl0ZW0nKX0gJHtwcmVmaXhDbGFzcygnc2xpZGUtaXRlbScpfWAgKyB0Ll9nZXRSZWFsSW5kZXgoaW5kZXgpfT5cbiAgICAgICAgICAgIHtDaGlsZH1cbiAgICAgICAgICAgIDwvZGl2PjtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgdCA9IHRoaXM7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8ZGl2IHJlZj1cInJvb3RcIiBjbGFzc05hbWU9e2NsYXNzbmFtZXMoe1xuICAgICAgICAgICAgICAgIFtgJHtwcmVmaXhDbGFzcygnc2xpZGUnKX1gXTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBbYCR7cHJlZml4Q2xhc3MoJ3NsaWRlLW9mZicpfWBdOiB0LnN0YXRlLmRpc2FibGVkLFxuICAgICAgICAgICAgICAgIFt0LnByb3BzLmNsYXNzTmFtZV06ICEhdC5wcm9wcy5jbGFzc05hbWVcbiAgICAgICAgICAgIH0pfT5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtgJHtwcmVmaXhDbGFzcygnM0QnKX0gJHtwcmVmaXhDbGFzcygnc2xpZGUtdmlldycpfWB9IHN0eWxlPXt7aGVpZ2h0OiB0LnByb3BzLmhlaWdodH19PlxuICAgICAgICAgICAge3QuX3JlbmRlckl0ZW1zKCl9XG4gICAgICAgICAgICB7dC5fZHVtbXkgJiYgdC5fcmVuZGVySXRlbXModHJ1ZSl9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIHt0LnByb3BzLnNob3dOYXYgJiYgdC5sZW5ndGggPiAxICYmIDxTbGlkZU5hdiBhY3RpdmU9e3QuX2dldFJlYWxJbmRleCh0LmN1cnJlbnRQb3NJbmRleCl9IG51bT17dC5wcm9wcy5jaGlsZHJlbi5sZW5ndGh9Lz59XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKTtcbiAgICB9XG59XG5cblNsaWRlLnByb3BUeXBlcyA9IHtcbiAgICBjbGFzc05hbWU6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgaGVpZ2h0OiBSZWFjdC5Qcm9wVHlwZXMub25lT2ZUeXBlKFtcbiAgICAgICAgUmVhY3QuUHJvcFR5cGVzLm51bWJlcixcbiAgICAgICAgUmVhY3QuUHJvcFR5cGVzLnN0cmluZ1xuICAgIF0pLFxuICAgIGFjdGl2ZTogUmVhY3QuUHJvcFR5cGVzLm51bWJlcixcbiAgICBhdXRvOiBSZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBsb29wOiBSZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBzaG93TmF2OiBSZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBvbk1vdW50OiBSZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBvblNsaWRlRW5kOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBvblNsaWRlQ2xpY2s6IFJlYWN0LlByb3BUeXBlcy5mdW5jLFxufTtcblxuU2xpZGUuZGVmYXVsdFByb3BzID0ge1xuICAgIGhlaWdodDogJzVyZW0nLFxuICAgIGFjdGl2ZTogMCxcbiAgICBhdXRvOiBmYWxzZSxcbiAgICBsb29wOiB0cnVlLFxuICAgIHNob3dOYXY6IGZhbHNlLFxuICAgIG9uTW91bnQ6IG5vb3AsXG4gICAgb25TbGlkZUVuZDogbm9vcCxcbiAgICBvblNsaWRlQ2xpY2s6IG5vb3Bcbn07XG5cblNsaWRlLmRpc3BsYXlOYW1lPSdTbGlkZSc7XG5cbm1vZHVsZS5leHBvcnRzID0gU2xpZGU7XG4iXSwic291cmNlUm9vdCI6Ii9zb3VyY2UvIn0=
